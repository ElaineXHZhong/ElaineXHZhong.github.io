<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[16_Call_Python]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-16-Call-Python%2F</url>
    <content type="text"><![CDATA[16-Nodejs如何调用Python函数 例子：用Nodejs的应用程序，调用Python的Machine Learning算法。 最简单的方式是使用随Nodejs打包的&quot;child_process&quot;包。 123456var spawn = require('child_process').spawn;var process = spawn('python',[ 'path_to_script.py', arg1, arg2]); 所有你需要做的就是确保在你的python脚本中导入sys，然后你可以使用sys.argv [1]，sys.argv[2]访问arg1、arg2等等。 要将数据发送回Nodejs，只需在python脚本中执行以下操作： 12print(dataToSendBack)sys.stdout.flush() 然后Nodejs可以使用以下方式监听数据： 123process.stdout.on('data', function (data)&#123;// Do something with the data returned from python script&#125;); 由于这允许使用spawn将多个参数传递给脚本，您可以重新构造一个python脚本，以便其中一个参数决定要调用哪个函数，另一个参数被传递给该函数等。 下面是一个具体的例子： start.js 123456789101112131415161718192021222324var express = require('express'); //import modulevar app = express(); // create its variableapp.listen(3000,function()&#123; // create a server running on port 3000 console.log('server running on port 3000');&#125;); // server can be accessed through localhost:3000// when the url if of the form localhost:3000/name,callName() function is excuted app.get('/name',callName);function callName(req,res)&#123; var spawn = require('child_process').spawn; // import chile_process module and user its spawn method, and assign create its variable var process = spawn('python',[ './hello.py', req.query.firstname, req.query.lastname ]); // parameters passed in spawn:1.type of script 2.list containing the path and arguments of the script process.stdout.on('data',function(data)&#123; // standard output data from script which executed res.send(data.toString()); // send this data to res object &#125;);&#125;; //http://localhost:3000/name?firstname=Mike&amp;lastname=Will//Output from Python-- First name: Mike Last name: Will//http://localhost:3000/name?firstname=elaine&amp;lastname=zhong//Output from Python-- First name: elaine Last name: zhong hello.py 1234567import sys# Takes first name and last name via command# line arguments and then display themprint("\n Output from Python-- \n\n")print("\n First name: " + sys.argv[1])print("\n Last name: " + sys.argv[2])# Save the script as hello.py 品尝了前菜，下面系统来讲讲Nodejs想要调用Python文件有哪些方法。 话说Nodejs是利用子进程来调用系统命令或者文件，它的子进程提供了与系统交互的重要接口，其主要API有： 标准输入、标准输出及标准错误输出的接口。 child.stdin 获取标准输入 child.stdout 获取标准输出 child.stderr 获取标准错误输出 获取子进程的PID：child.pid ： 提供生成子进程的方法：child_process.spawn(cmd, args=[], [options]) 提供直接执行系统命令的方法：child_process.exec(cmd, [options], callback) 提供调用脚本文件的方法：child_process.execFile(file, [args], [options], [callback]) 提供杀死进程的方法：child.kill(signal=‘SIGTERM’) 下面结合例子来解释： 利用子进程调用系统命令（获取系统内存使用情况） 新建nodejs文件，名为cmd_spawn.js，代码如下： 1234567891011121314var spawn = require('child_process').spawn;var free = spawn('free', ['-m']); // 捕获标准输出并将其打印到控制台 free.stdout.on('data', function (data) &#123; console.log('standard output:\n' + data); &#125;); // 捕获标准错误输出并将其打印到控制台 free.stderr.on('data', function (data) &#123; console.log('standard error output:\n' + data); &#125;); // 注册子进程关闭事件 free.on('exit', function (code, signal) &#123; console.log('child process eixt ,exit:' + code); &#125;); 运行node cmd_spawn.js和free -m的结果一模一样。 执行系统命令（child_process.exec()） 功能比上面的强大一点，比如我想关注天气，现在我要curl一下天气的接口返回json格式的数据，可能我要对它进行一番操作，这里就打印出来不操作。 新建nodejs文件，名为cmd_exec.js: 1234567891011121314var exec = require('child_process').exec; var cmdStr = 'curl http://www.weather.com.cn/data/sk/101010100.html';exec(cmdStr, function(err,stdout,stderr)&#123; if(err) &#123; console.log('get weather api error:'+stderr); &#125; else &#123; /* 这个stdout的内容就是上面我curl出来的这个东西： &#123;"weatherinfo":&#123;"city":"北京","cityid":"101010100","temp":"3","WD":"西北风","WS":"3级","SD":"23%","WSE":"3","time":"21:20","isRadar":"1","Radar":"JC_RADAR_AZ9010_JB","njd":"暂无实况","qy":"1019"&#125;&#125; */ var data = JSON.parse(stdout); console.log(data); &#125;&#125;); 直接curl出来和通过运行脚本的出来的结果是一样的：node cmd_exec.js的结果与curl http://www.weather.com.cn/data/sk/101010100.html是一样的。 调用传参数的shell脚本（child_process.execFile()） 这个要先准备个shell脚本，比如我要连到一台服务器，来修改它的密码，则我要提供IP，user，new pwd，old pwd，新建shell脚本文件change_password.sh： 12345678910111213141516171819202122232425262728293031323334#!/bin/shIP=""NAME=""PASSWORD=""NEWPASSWORD=""while getopts "H:U:P:N:" arg #选项后面的冒号表示该选项需要参数do case $arg in H) IP=$OPTARG ;; U) NAME=$OPTARG ;; P) PASSWORD=$OPTARG ;; N) NEWPASSWORD=$OPTARG ;; ?) #当有不认识的选项的时候arg为? echo "含有未知参数" exit 1 ;; esacdone#先获取useridUSERID=`/usr/bin/ipmitool -I lanplus -H $IP -U $NAME -P $PASSWORD user list | grep root | awk '&#123;print $1&#125;'`# echo $USERID#根据userid来修改密码/usr/bin/ipmitool -I lanplus -H $IP -U $NAME -P $PASSWORD user set password $USERID $NEWPASSWORD 然后我准备一个nodejs文件来调用这个shell脚本，叫file_changepwd.js： 123456789var callfile = require('child_process'); var ip = '1.1.1.1';var username = 'test';var password = 'pwd';var newpassword = 'newpwd';callfile.execFile('change_password.sh',['-H', ip, '-U', username, '-P', password, '-N', newpassword],null,function (err, stdout, stderr) &#123; callback(err, stdout, stderr);&#125;); 看过上面的，其实调用python脚本就没什么悬念了，本质上也就是执行命令。 调用python脚本（python脚本本身是传参数的） 下面这段是对python传参数的简单说明： 123456789101112# -*-coding:utf-8 -*-'''需要模块：sys参数个数：len(sys.argv)脚本名： sys.argv[0]参数1： sys.argv[1]参数2： sys.argv[2]'''import sysprint u"脚本名：", sys.argv[0]for i in range(1, len(sys.argv)):#这里参数从1开始 print u"参数", i, sys.argv[i] 准备一个nodejs文件来调用这个python脚本，file_python.js: 123456789101112131415161718var exec = require('child_process').exec;var arg1 = 'hello'var arg2 = 'jzhou'exec('python py_test.py '+ arg1+' '+arg2+' ',function(error,stdout,stderr)&#123; if(stdout.length &gt;1)&#123; console.log('you offer args:',stdout); &#125; else &#123; console.log('you don\'t offer args'); &#125; if(error) &#123; console.info('stderr : '+stderr); &#125;&#125;);py_test.py内容如下：# -*-coding:utf-8 -*-import sysprint sys.argv 比较exec和spawn exec将子进程输出结果暂放在buffer中，在结果完全返回后，再将输出一次性的以回调函数返回。如果exec的buffer体积设置的不够大，它将会以一个“maxBuffer exceeded”错误失败告终。而spawn在子进程开始执行后，就不断的将数据从子进程返回给主进程，它没有回调函数，它通过流的方式发数据传给主进程，从而实现了多进程之间的数据交换。这个功能的直接用应用场景就是“系统监控”。 exec更方便一些,将整个命令放在第一个参数中，而spqwn需要拆分。 child_process.spawn('python', ['support.py', i]) child_process.exec('python support.py '+i, callback) 上面的方法主要都是执行整个Python文件的，下面介绍Github上一个在传递参数、返回值、异常上很有优势的模块：python.js 附上项目于地址：https://github.com/monkeycz/python.js]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01_jQuery_introduction]]></title>
    <url>%2F2019%2F04%2F22%2FjQuery-01-jQuery-introduction%2F</url>
    <content type="text"><![CDATA[jQuery教程 jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程。 实例1 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("p").click(function()&#123; $(this).hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;如果你点我，我就会消失。&lt;/p&gt; &lt;p&gt;继续点我!&lt;/p&gt; &lt;p&gt;接着点我!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 什么是jQuery？ jQuery是一个JavaScript函数库，是一个轻量级的&quot;写的少，做的多&quot;的JavaScript库。 jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 除此之外，Jquery还提供了大量的插件。 为什么使 jQuery？ 目前网络上有大量开源的 JS 框架, 但是 jQuery 是目前最流行的 JS 框架，而且提供了大量的扩展。 很多大公司都在使用 jQuery， 例如: Google Microsoft IBM Netflix jQuery安装 网页中添加 jQuery 可以通过多种方法在网页中添加 jQuery。 您可以使用以下方法： 从 jquery.com 下载 jQuery 库 从 CDN 中载入 jQuery, 如从 Google 中加载 jQuery 下载 jQuery 有两个版本的 jQuery 可供下载： Production version - 用于实际的网站中，已被精简和压缩。 Development version - 用于测试和开发（未压缩，是可读的代码） 以上两个版本都可以从 jquery.com 中下载。 jQuery 库是一个 JavaScript 文件，您可以使用 HTML 的 标签引用它： 123&lt;head&gt; &lt;script src="jquery-1.10.2.min.js"&gt;&lt;/script&gt;&lt;/head&gt; 提示： 将下载的文件放在网页的同一目录下，就可以使用jQuery。 您是否很疑惑为什么我们没有在 标签中使用 type=“text/javascript” ？在 HTML5 中，不必那样做了。JavaScript 是 HTML5 以及所有现代浏览器中的默认脚本语言！ 一、jQuery语法 jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。 基础语法： $(selector).action() 美元符号定义 jQuery 选择符（selector）“查询&quot;和&quot;查找” HTML 元素 jQuery 的 action() 执行对元素的操作 实例: $(this).hide() - 隐藏当前元素 $(“p”).hide() - 隐藏所有 元素 $(“p.test”).hide() - 隐藏所有 class=“test” 的 元素 $(&quot;#test&quot;).hide() - 隐藏所有 id=“test” 的元素 你对 CSS 选择器熟悉吗？ jQuery 使用的语法是 XPath 与 CSS 选择器语法的组合。 1. 文档就绪事件 123$(document).ready(function)&#123; // jQuery代码&#125; 所有 jQuery 函数位于一个 document ready 函数中，这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。 如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子： 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 **提示：**简洁写法（与以上写法效果相同）: 123$(function)&#123; // jQuery代码&#125; 以上两种方式你可以选择你喜欢的方式实现文档就绪后执行 jQuery 方法。 笔记： jQuery 入口函数: 1234567$(document).ready(function()&#123; // 执行代码&#125;);或者$(function()&#123; // 执行代码&#125;); JavaScript 入口函数: 123window.onload = function () &#123; // 执行代码&#125; jQuery 入口函数与 JavaScript 入口函数的区别： jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。 二、jQuery 选择器 jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 1. jQuery 选择器 jQuery 选择器基于元素的 id、类、类型、属性、属性值等&quot;查找&quot;（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头：$()。 2. 元素选择器 jQuery 元素选择器基于元素名选取元素。 在页面中选取所有 元素: $(“p”) 实例2 用户点击按钮后，所有 元素都隐藏： 12345$(document).read(function()&#123; $('button').click(function()&#123; $('p').hide(); &#125;);&#125;); 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/jquery/2.0.0/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("p").hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;这是一个标题&lt;/h2&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另一个段落。&lt;/p&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 3. #id 选择器 jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。 通过 id 选取元素语法如下： $(&quot;#test&quot;) 实例3 当用户点击按钮后，有 id=“test” 属性的元素将被隐藏： 12345$(document).ready(function()&#123; $("button").click(function()&#123; $("#test").hide(); &#125;);&#125;); 4. .class 选择器 jQuery 类选择器可以通过指定的 class 查找元素。 语法如下： $(&quot;.test&quot;) 实例4 用户点击按钮后所有带有 class=“test” 属性的元素都隐藏： 12345$(document).read(function()&#123; $("button").click(function()&#123; $(".test").hide(); &#125;);&#125;); 5. 更多实例 $(&quot;*&quot;) ：选取所有元素； 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/jquery/2.0.0/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("*").hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;这是一个标题&lt;/h2&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另一个段落。&lt;/p&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1点击“点我”按钮后，“这是一个标题”+“这是一个段落”+“这是另一个段落”全部消失 $(this)：选取当前 HTML 元素； 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/jquery/2.0.0/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $(this).hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;这是一个标题&lt;/h2&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另一个段落。&lt;/p&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1点击“点我”按钮后，“点我”按钮消失 $(“p.intro”)：选取 class 为 intro 的 元素； 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/jquery/2.0.0/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("p.intro").hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2 class="intro"&gt;这是一个标题&lt;/h2&gt; &lt;p class="intro"&gt;这是一个段落，点击按钮隐藏。&lt;/p&gt; &lt;p&gt;这是另一个段落，点击按钮不会隐藏。&lt;/p&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1点击“点我”按钮后，“这是一个段落，点击按钮隐藏。”消失 $(“p:first”)：选取第一个 元素； 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/jquery/2.0.0/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("p:first").hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;这是标题&lt;/h2&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1点击“点我”按钮后，“这是一个段落。”消失 $(“ul li:first”)：选取第一个 元素的第一个 元素； 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/jquery/2.0.0/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("ul li:first").hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;List 1:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;List 2:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;/ul&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1点击“点我”按钮后，第一个“Coffee”消失 $(“ul li:first-child”)：选取每个 元素的第一个 元素； 1点击“点我”按钮后，两个“Coffee”都消失 $(&quot;[href]&quot;)：选取带有 href 属性的元素； 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("[href]").hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;这是标题&lt;/h2&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; &lt;p&gt;&lt;a href="http://www.runoob.com/html/"&gt;HTML 教程&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="http://www.runoob.com/css/"&gt;CSS 教程&lt;/a&gt;&lt;/p&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1点击“点我”按钮后，“HTML 教程”和“CSS 教程”消失 $(“a[target=’_blank’]”)： 选取所有 target 属性值等于 “_blank” 的 元素； 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("a[target='_blank']").hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;这是标题&lt;/h2&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; &lt;p&gt;&lt;a href="http://www.runoob.com/html/" target="_blank"&gt;HTML 教程&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="http://www.runoob.com/css/"&gt;CSS 教程&lt;/a&gt;&lt;/p&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1点击“点我”按钮后，“HTML 教程”消失 $(“a[target!=’_blank’]”)：选取所有 target 属性值不等于 “_blank” 的 元素； 1点击“点我”按钮后，“CSS 教程”消失 $(&quot;:button&quot;)：选取所有 type=“button” 的 元素 和 元素； 1点击“点我”按钮后，“点我”按钮消失 $(“tr:even”)：选取偶数位置的 元素； 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("tr:even").css("background-color","yellow"); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;欢迎访问我的主页&lt;/h1&gt; &lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;网站名&lt;/th&gt; &lt;th&gt;网址&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Google&lt;/td&gt; &lt;td&gt;http://www.google.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Baidu&lt;/td&gt; &lt;td&gt;http://www.baidu.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;菜鸟教程&lt;/td&gt; &lt;td&gt;http://www.runoob.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;淘宝&lt;/td&gt; &lt;td&gt;http://www.taobao.com&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Facebook&lt;/td&gt; &lt;td&gt;http://www.facebook.com&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; $(“tr:odd”)：选取奇数位置的 元素。 6. 独立文件中使用jQuery函数 如果您的网站包含许多页面，并且您希望您的 jQuery 函数易于维护，那么请把您的 jQuery 函数放到独立的 .js 文件中。 把它们放到一个单独的文件中会更好，就像这样（通过 src 属性来引用文件）： 12345&lt;head&gt; &lt;script src='http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js'&gt; &lt;/script&gt; &lt;script src='my_jquery_functions.js'&gt;&lt;/script&gt;&lt;/head&gt; 笔记： 通过 $(&quot;:button&quot;) 可以选取所有 type=“button” 的 元素 和 元素，如果去掉冒号，$(“button”)只能获取 元素。 1234&lt;p id="test1"&gt;点进这里测试 &lt;b&gt;button&lt;/b&gt;&lt;/p&gt;&lt;p id="test2"&gt;点进这里测试 &lt;b&gt;:button&lt;/b&gt;&lt;/p&gt;&lt;button&gt;Button 按钮&lt;/button&gt;&lt;input type="button" value="Input 按钮"&gt; 关于 : 和 [] 这两个符号的理解: **：**可以理解为种类的意思，如：p:first，p 的种类为第一个。 [] 很自然的可以理解为属性的意思，如：[href] 选取带有 href 属性的元素。 12345678910111213141516$("#id", ".class") 复合选择器$(div p span) 层级选择器 //div下的p元素中的span元素$(div&gt;p) 父子选择器 //div下的所有p元素$(div+p) 相邻元素选择器 //div后面的p元素(仅一个p)$(div~p) 兄弟选择器 //div后面的所有p元素(同级别)$(.p:last) 类选择器 加 过滤选择器 第一个和最后一个（first 或者 last）$("#mytable td:odd") 层级选择 加 过滤选择器 奇偶（odd 或者 even）$("div p:eq(2)") 索引选择器 div下的第三个p元素（索引是从0开始）$("a[href='www.baidu.com']") 属性选择器$("p:contains(test)") // 内容过滤选择器，包含text内容的p元素$(":emtyp") //内容过滤选择器，所有空标签（不包含子标签和内容的标签）parent 相反$(":hidden") //所有隐藏元素 visible $("input:enabled") //选取所有启用的表单元素$(":disabled") //所有不可用的元素$("input:checked") //获取所有选中的复选框单选按钮等$("select option:selected") //获取选中的选项元素 三、jQuery-HTML 1.jQuery - 获取内容和属性 jQuery 拥有可操作 HTML 元素和属性的强大方法。 (1) jQuery DOM 操作 jQuery 中非常重要的部分，就是操作 DOM 的能力。jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。 DOM = Document Object Model（文档对象模型）DOM 定义访问 HTML 和 XML 文档的标准：“W3C 文档对象模型独立于平台和语言的界面，允许程序和脚本动态访问和更新文档的内容、结构以及样式。” (2) 获得内容 - text()、html() 以及 val() 三个简单实用的用于 DOM 操作的 jQuery 方法： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 下面的例子演示如何通过 jQuery text() 和 html() 方法来获得内容： 123456$("#btn1").click(function()&#123; alert("Text: " + $("#test").text());&#125;);$("#btn2").click(function()&#123; alert("HTML: " + $("#test").html());&#125;); 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("#btn1").click(function()&#123; alert("Text: " + $("#test").text()); &#125;); $("#btn2").click(function()&#123; alert("HTML: " + $("#test").html()); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="test"&gt;这是段落中的 &lt;b&gt;粗体&lt;/b&gt; 文本。&lt;/p&gt; &lt;button id="btn1"&gt;显示文本&lt;/button&gt; &lt;button id="btn2"&gt;显示 HTML&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 12点击“显示文本”按钮：Text: 这是段落中的 粗体 文本。点击“显示HTML”按钮：HTML: 这是段落中的 &lt;b&gt;粗体&lt;/b&gt; 文本。 下面的例子演示如何通过 jQuery val() 方法获得输入字段的值： 123$("#btn1").click(function()&#123; alert("值为: " + $("#test").val());&#125;); 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;meta charset="utf-8"&gt; &lt;head&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; alert("值为: " + $("#test").val()); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;名称: &lt;input type="text" id="test" value="菜鸟教程"&gt;&lt;/p&gt; &lt;button&gt;显示值&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1在“名称”框中输入elaine，点击“显示值”按钮：值为: elaine （3）获取属性 - attr() jQuery attr() 方法用于获取属性值。下面的例子演示如何获得链接中 href 属性的值： 123$("button").click(function()&#123; alert($("#runoob").attr("href"));&#125;); 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; alert($("#runoob").attr("href")); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;a href="http://www.runoob.com" id="runoob"&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt; &lt;button&gt;显示 href 属性的值&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1点击“显示 href 属性的值”按钮： http://www.runoob.com 笔记： 1. attr 和 prop 的区别介绍： 对于 HTML 元素本身就带有的固有属性，在处理时，使用 prop 方法。 对于 HTML 元素我们自己自定义的 DOM 属性，在处理时，使用 attr 方法。 实例 1： 1&lt;a href="https://www.runoob.com" target="_self" class="btn"&gt;菜鸟教程&lt;/a&gt; 这个例子里 元素的 DOM 属性有: href、target 和 class，这些属性就是 元素本身就带有的属性，也是 W3C 标准里就包含有这几个属性，或者说在 IDE 里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使用 prop 方法。 1&lt;a href="#" id="link1" action="delete" rel="nofollow"&gt;删除&lt;/a&gt; 这个例子里 元素的 DOM 属性有: href、id 和 action，很明显，前两个是固有属性，而后面一个 action 属性是我们自己自定义上去的， 元素本身是没有这个属性的。这种就是自定义的 DOM 属性。处理这些属性时，建议使用 attr 方法。 prop()函数的结果: ​ 1.如果有相应的属性，返回指定属性值。 ​ 2.如果没有相应的属性，返回值是空字符串。 attr()函数的结果: ​ 1.如果有相应的属性，返回指定属性值。 ​ 2.如果没有相应的属性，返回值是 undefined。 对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。 对于HTML元素我们自己自定义的DOM属性，在处理时，使用 attr 方法。 具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop() 2. jQuery - 设置内容和属性 (1) 设置内容 - text()、html() 以及 val() 我们将使用前一章中的三个相同的方法来设置内容： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 下面的例子演示如何通过 text()、html() 以及 val() 方法来设置内容： 123456789$("#btn1").click(function()&#123; $("#test1").text("Hello world!");&#125;);$("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;");&#125;);$("#btn3").click(function()&#123; $("#test3").val("RUNOOB");&#125;); 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("#btn1").click(function()&#123; $("#test1").text("Hello world!"); &#125;); $("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;"); &#125;); $("#btn3").click(function()&#123; $("#test3").val("RUNOOB"); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="test1"&gt;这是一个段落。&lt;/p&gt; &lt;p id="test2"&gt;这是另外一个段落。&lt;/p&gt; &lt;p&gt;输入框: &lt;input type="text" id="test3" value="菜鸟教程"&gt;&lt;/p&gt; &lt;button id="btn1"&gt;设置文本&lt;/button&gt; &lt;button id="btn2"&gt;设置 HTML&lt;/button&gt; &lt;button id="btn3"&gt;设置值&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 123点击“设置文本”按钮：“这是一个段落”变成“Hello world!”；点击“设置HTML”按钮：“这是另外一个段落”变成加粗的&quot;Hello world!”；点击“设置值”按钮：输入框中的文字变为“RUNOOB”。 （2）text()、html() 以及 val() 的回调函数 上面的三个 jQuery 方法：text()、html() 以及 val()，同样拥有回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 下面的例子演示带有回调函数的 text() 和 html()： 1234567891011$("#btn1").click(function()&#123; $("#test1").text(function(i,origText)&#123; return "旧文本: " + origText + " 新文本: Hello world! (index: " + i + ")"; &#125;);&#125;); $("#btn2").click(function()&#123; $("#test2").html(function(i,origText)&#123; return "旧 html: " + origText + " 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: " + i + ")"; &#125;);&#125;); 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("#btn1").click(function()&#123; $("#test1").text(function(i,origText)&#123; return "旧文本: " + origText + " 新文本: Hello world! (index: " + i + ")"; &#125;); &#125;); $("#btn2").click(function()&#123; $("#test2").html(function(i,origText)&#123; return "旧 html: " + origText + " 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: " + i + ")"; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="test1"&gt;这是一个有 &lt;b&gt;粗体&lt;/b&gt; 字的段落。&lt;/p&gt; &lt;p id="test2"&gt;这是另外一个有 &lt;b&gt;粗体&lt;/b&gt; 字的段落。&lt;/p&gt; &lt;button id="btn1"&gt;显示 新/旧 文本&lt;/button&gt; &lt;button id="btn2"&gt;显示 新/旧 HTML&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 12点击“显示 新/旧 文本”按钮：“这是一个有 粗体 字的段落”变为“旧文本: 这是一个有 粗体 字的段落。 新文本: Hello world! (index: 0)”；点击“显示 新/旧 HTML”按钮：“这是另外一个有 粗体 字的段落”变为“旧 html: 这是另外一个有 粗体 字的段落。 新 html: Hello world! (index: 0)”。 （3）设置属性 - attr() jQuery attr() 方法也用于设置/改变属性值。下面的例子演示如何改变（设置）链接中 href 属性的值： 123$("button").click(function()&#123; $("#runoob").attr("href","http://www.runoob.com/jquery");&#125;); 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("#runoob").attr("href","http://www.runoob.com/jquery"); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;a href="http://www.runoob.com" id="runoob"&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt; &lt;button&gt;修改 href 值&lt;/button&gt; &lt;p&gt;点击按钮修改后，可以点击链接查看链接地址是否变化。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; attr() 方法也允许同时设置多个属性。下面的例子演示如何同时设置 href 和 title 属性： 123456$("button").click(function()&#123; $("#runoob").attr(&#123; "href" : "http://www.runoob.com/jquery", "title" : "jQuery 教程" &#125;);&#125;); 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("#runoob").attr(&#123; "href" : "http://www.runoob.com/jquery", "title" : "jQuery 教程" &#125;); // 通过修改的 title 值来修改链接名称 title = $("#runoob").attr('title'); $("#runoob").html(title); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;a href="http://www.runoob.com" id="runoob"&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt; &lt;button&gt;修改 href 和 title&lt;/button&gt; &lt;p&gt;点击按钮修改后，可以查看 href 和 title 是否变化。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 1点击“修改 href 和 title”按钮后，“菜鸟教程”及其连接变成“jQuery 教程”及其链接。 （4）attr() 的回调函数 jQuery 方法 attr()，也提供回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 下面的例子演示带有回调函数的 attr() 方法： 12345$("button").click(function()&#123; $("#runoob").attr("href", function(i,origValue)&#123; return origValue + "/jquery"; &#125;);&#125;); 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("#runoob").attr("href", function(i, origValue)&#123; return origValue + "/jquery"; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;a href="http://www.runoob.com" id="runoob"&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt; &lt;button&gt;修改 href 值&lt;/button&gt; &lt;p&gt;点击按钮修改后，可以点击链接查看 href 属性是否变化。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 3. jQuery - 添加元素 (1) 添加新的 HTML 内容 我们将学习用于添加新内容的四个 jQuery 方法： append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 (2) jQuery append() 方法 jQuery append() 方法在被选元素的结尾插入内容（仍然该元素的内部）。 1$("p").append("追加文本"); 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("#btn1").click(function()&#123; $("p").append(" &lt;b&gt;追加文本&lt;/b&gt;。"); &#125;); $("#btn2").click(function()&#123; $("ol").append("&lt;li&gt;追加列表项&lt;/li&gt;"); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; &lt;ol&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;/ol&gt; &lt;button id="btn1"&gt;添加文本&lt;/button&gt; &lt;button id="btn2"&gt;添加列表项&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; (3) jQuery prepend() 方法 jQuery prepend() 方法在被选元素的开头插入内容。 1$("p").prepend("在开头追加文本"); 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("#btn1").click(function()&#123; $("p").prepend("&lt;b&gt;在开头追加文本&lt;/b&gt;。 "); &#125;); $("#btn2").click(function()&#123; $("ol").prepend("&lt;li&gt;在开头添加列表项&lt;/li&gt;"); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; &lt;ol&gt; &lt;li&gt;列表 1&lt;/li&gt; &lt;li&gt;列表 2&lt;/li&gt; &lt;li&gt;列表 3&lt;/li&gt; &lt;/ol&gt; &lt;button id="btn1"&gt;添加文本&lt;/button&gt; &lt;button id="btn2"&gt;添加列表项&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; (4) 通过 append() 和 prepend() 方法添加若干新元素 append() 和 prepend() 方法能够通过参数接收无限数量的新元素。可以通过 jQuery 来生成文本/HTML（就像上面的例子那样），或者通过 JavaScript 代码和 DOM 元素。 在下面的例子中，我们创建若干个新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 append() 方法把这些新元素追加到文本中（对 prepend() 同样有效）： 12345678function appendText()&#123; var txt1="&lt;p&gt;文本。&lt;/p&gt;"; // 使用 HTML 标签创建文本 var txt2=$("&lt;p&gt;&lt;/p&gt;").text("文本。"); // 使用 jQuery 创建文本 var txt3=document.createElement("p"); txt3.innerHTML="文本。"; // 使用 DOM 创建文本 text with DOM $("body").append(txt1,txt2,txt3); // 追加新元素&#125; 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; function appendText()&#123; var txt1="&lt;p&gt;文本。&lt;/p&gt;"; // 使用 HTML 标签创建文本 var txt2=$("&lt;p&gt;&lt;/p&gt;").text("文本。"); // 使用 jQuery 创建文本 var txt3=document.createElement("p"); txt3.innerHTML="文本。"; // 使用 DOM 创建文本 text with DOM $("body").append(txt1,txt2,txt3); // 追加新元素 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;button onclick="appendText()"&gt;追加文本&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; (5) jQuery after() 和 before() 方法 jQuery after() 方法在被选元素之后插入内容。jQuery before() 方法在被选元素之前插入内容。 12$("img").after("在后面添加文本");$("img").before("在前面添加文本"); (6) 通过 after() 和 before() 方法添加若干新元素 after() 和 before() 方法能够通过参数接收无限数量的新元素。可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建新元素。 在下面的例子中，我们创建若干新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 after() 方法把这些新元素插到文本中（对 before() 同样有效）： 12345678function afterText()&#123; var txt1="&lt;b&gt;I &lt;/b&gt;"; // 使用 HTML 创建元素 var txt2=$("&lt;i&gt;&lt;/i&gt;").text("love "); // 使用 jQuery 创建元素 var txt3=document.createElement("big"); // 使用 DOM 创建元素 txt3.innerHTML="jQuery!"; $("img").after(txt1,txt2,txt3); // 在图片后添加文本&#125;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15_Await]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-15-Await%2F</url>
    <content type="text"><![CDATA[15-Node.js中Promise、Async、await使用 async是“异步”的简写，await是“async wait”的简写。async用于申明一个function是异步的，而await用于等待一个异步方法执行完成。 async让方法变成异步； await等待异步方法执行完成。 async让方法变成异步。在终端里用node执行这段代码，你会发现输出了 Promise{‘Hello async’}，这时候它返回的是Promise。 12345// 首先定义一个普通方法getData，返回一个数据function getData()&#123; return '这是一个数据';&#125;console.log(getData()); // 打印此方法中的数据 用async让方法变成Promise的异步方法： 1234async function getData()&#123; return '这是一个数据';&#125;console.log(getData()); 12&gt;node test.jsPromise &#123; &apos;这是一个数据&apos; &#125; 如何获取async异步方法里面的数据： 用类似于回调的方法和Promise中.then()方法 1234567async function getData()&#123; return '这是一个数据';&#125;var p = getData(); // 此时p是一个Promise对象p.then((data)=&gt;&#123; console.log(data); // 拿到异步方法里面的数据&#125;); 用await方法（可以获取异步方法里面的数据，但是必须用在异步方法里面） 12345678async function getData()&#123; return '这是一个数据';&#125;async function test()&#123; var d = await getData(); console.log(d);&#125;test(); // 打印'这是一个数据' async阻塞的功能，可以把异步改成一个同步 1234567891011async function getData()&#123; console.log(2); return '这是一个数据';&#125;async function test()&#123; console.log(1); var d = await getData(); console.log(d); console.log(3);&#125;test(); 12345&gt;node test.js12这是一个数据3 如果是异步的，应该是132不是123，说明await让方法变成了同步的。 用Promise方法 123456789101112function getData()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; var username = '张三'; resolve(username); &#125;,1000); &#125;);&#125;var p = getData();p.then(function(d)&#123; console.log(d);&#125; 换成await就简单了 12345678910111213function getData()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; var username = '张三'; resolve(username); &#125;,1000); &#125;);&#125;async function test()&#123; var data = await getData(); console.log(data);&#125;test();]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14_Restful_API]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-14-Restful-API%2F</url>
    <content type="text"><![CDATA[14-Node.js RESTful API 什么是REST? REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。 注意，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。 什么是REST API? 要解释什么是REST，你应该先了解什么是API（Application Programming Interface，应用程序编程接口），形象一点说就像是腾讯、阿里巴巴这些公司提供的API接口，我们可以编写一个软件去跟这个API接口连接或交互。 举个栗子，比如你可以用手机的某些软件分享内容到微信朋友圈，这个软件就是与微信的API进行了交互。知道了API，就容易理解REST了。REST是什么呢？它是一种架构风格，是腾讯、阿里巴巴等公司建立API时要遵守的一种风格，当然也有其他的风格可以用。 要具体解析什么是REST，我们还必须提到Web，因为REST是以Web为平台的。 Web是什么: 分布式信息系统为超文本文件和其他对象（资源）提供访问入口。资源是Web架构的关键点,需要 3个操作：识别(identify) 表示(represent) 交互(interact with)。通过这三个操作，又引出三个概念：uri（统一资源标识符包括url和urn）识别资源；representation （例如html，xml，图片，视频等等）表示资源；通过协议（包括http，ftp等等）与资源进行交互。 所以REST就是选择通过使用http协议和uri，利用client/server model对资源进行CRUD (Create/Read/Update/Delete)增删改查操作。 为什么要使用REST风格？ REST风格的限制及其优点： 客户-服务器（Client-Server）客户端服务器分离； 优点：提高用户界面的便携性（操作简单），简化服务器提高可伸缩性（高性能，低成本），允许组件分别优化（可以让服务端和客户端分别进行改进和优化）。 无状态（Stateless）客户端的每个请求要包含服务器所需要的所有信息； 优点：提高可见性（可以单独考虑每个请求），提高了可靠性（更容易从局部故障中修复），提高了可靠性（更容易从局部故障中修复）。 缓存（Cachable）服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的信息发送请求； 优点：减少交互次数，减少交互的平均延迟。 分层系统（Layered System）系统组件不需要知道与他交流组件之外的事情。封装服务，引入中间层； 优点：限制了系统的复杂性，提高可扩展性。 统一接口（Uniform Interface）； 优点：提高交互的可见性，鼓励单独改善组件。 支持按需代码（Code-On-Demand 可选）； 优点：提高可扩展性… 举例说明什么是Representation，什么是State，以及什么是Representation State Transfer Representation 例如我订阅了一个人的博客，想要获取他发表的所有文章（这里『他发表的所有文章』就是一个资源Resource）。于是我就向他的服务发出请求，说『我要获取你发表的所有文章，最好是atom格式的』，这时候服务器向你返回了atom格式的文章列表第一页（这里『atom格式的文章列表』就是表征Representation）。 State 你看到了第一页的页尾，想要看第二页，这时候有趣的事情就来了。如果服务器记录了应用的状态（stateful），那么你只要向服务询问『我要看下一页』，那么服务器自然就会返回第二页。类似的，如果你当前在第二页，想服务器请求『我要看下一页』，那就会得到第三页。但是REST的服务器恰恰是无状态的（stateless），服务器并没有保持你当前处于第几页，也就无法响应『下一页』这种具有状态性质的请求。因此客户端需要去维护当前应用的状态（application state），也就是『如何获取下一页资源』。当然，『下一页资源』的业务逻辑必然是由服务端来提供。服务器在文章列表的atom表征中加入一个URI超链接（hyper link），指向下一页文章列表对应的资源。客户端就可以使用统一接口（Uniform Interface）的方式，从这个URI中获取到他想要的下一页文章列表资源。上面的『能够进入下一页』就是应用的状态（State）。 Representation State Transfer 服务器把『能够进入下一页』这个状态以atom表征形式**传输（Transfer）给客户端就是表征状态传输（REpresentational State Transfer）**这个概念。 举个具体API的例子： 1234567891011121314151617181920212223242526272829// 请求GET /posts HTTP/1.1Accept: application/atom+xml// 响应HTTP/1.1 200 OKContent-Type: application/atom+xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;feed xmlns="http://www.w3.org/2005/Atom"&gt; &lt;title&gt;Posts&lt;/title&gt; &lt;link href="http://example.org/posts" rel="self" /&gt; &lt;link href="http://example.org/posts?pn=2" rel="next" /&gt; &lt;id&gt;urn:uuid:60a76c80-d399-11d9-b91C-0003939e0af6&lt;/id&gt; &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt; &lt;entry&gt; &lt;title&gt;Post XXX&lt;/title&gt; &lt;link href="http://example.org/post-xxx" /&gt; &lt;id&gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&lt;/id&gt; &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt; &lt;content type="xhtml"&gt; &lt;div xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;p&gt;This is the post content.&lt;/p&gt; &lt;/div&gt; &lt;/content&gt; &lt;/entry&gt; &lt;entry&gt;...&lt;/entry&gt;&lt;/feed&gt; 上面atom格式中的多个元素，它们分别定义了当前状态下合法的状态转移。 例如，这是一个指向自己的链接，其中rel属性指定了状态转移的关系为自身。 1&lt;link href="http://example.org/posts" rel="self" /&gt; 这是下一页的链接， 1&lt;link href="http://example.org/posts?pn=2" rel="next" /&gt; 如果当前不是第一页的话，就会有类似如下的链接来表示上一页， 1&lt;link href="http://example.org/posts?pn=2" rel="prev" /&gt; 而这个是某一篇文章的链接， 1&lt;link href="http://example.org/post-xxx" /&gt; 总结一下，就是： 服务器生成包含状态转移的表征数据，用来响应客户端对于一个资源的请求； 客户端借助这份表征数据，记录了当前的应用状态以及对应可转移状态的方式。 为了要实现这一系列的功能，一个不可或缺的东西就是超文本（hypertext）或者说超媒体类型（hypermedia type）。这绝对不是一个简简单单的媒体类型（例如，JSON属性列表）可以做到的。 REST是怎么产生的？ http是目前在互联网上使用最多的协议，没有之一。可是http的创始人一直都觉得，在过去10几年来，所有的人都在错误的使用Http. 这句话怎么说呢？如果说你要删除一个数据，以往的做法通常是 delete/{id}。如果你要更新一个数据，可能是Post数据放Body，然后方法是 update/{id}， 或者是artichle/{id}?method=update。 这种做法让Roy Fielding很暴燥，他觉得这个世界不该这样的，所有的人都在误解而且在严重错误的误解Http的设计初衷，好比是发明了火药却只用它来做烟花爆竹。那么正确的使用方式是什么呢？如果你要看Rest各种特性，你恐怕真的很难理解Rest，但是如果你看错误的使用http的人倒底儿了哪些错，什么是Rest就特别容易理解了。 七宗罪的第一条，混乱。 一万个人心里有一万个Url的命名规则，Url是统一资源定位符，重点是资源。而很多人却把它当成了万金油，每一个独立的虚拟的网页都可以随意使用，各种操作都能够迭加。这是混乱的来源之一。 第二条，贪婪。 有状态和无状态全部混在一起。特别是在购物车或者是登录的应用中，经常刷新就丢失带来的用户体验简直棒棒哒。每一个请求并不能单独的响应一些功能，很多的功能混杂在一起里。 这是人性贪婪的本质，也是各种Hack的起源，只要能够把问题解决掉，总会有人用他认为最方便的方式去解决问题，比如说汽车门把手坏掉了直接系根绳子当把手，emmmm这样确实很棒啊。 第三条，无序。 返回的结果往往是很随意，各种错误信息本来就是用Http的状态码构成的，可是很多人还是喜欢把错误信息返回在返回值中。最常见的就是Code和Message，当然对于这一点，我个人是保留疑问的，我的观点是，Http本身的错误和服务器的内部错误还是需要在不断层面分开的，不能混在一起。可是在大神眼里并非如此，这个再议。 好了我编不下去了。那么怎么解决这些问题呢？强迫症患者的福音就是先颁规则，第一个规则就是明确Url是什么，该怎么用。 就是所有的Url本质来讲，都应该是一种资源。一个独立的Url地址，就是对应一个独一无二的资源。怎么样？这种感觉是不是棒棒哒？一个冰淇淋，一个老师，一间房子，在Url上对应的都是一个资源，不会有多余的Url跟他对应，也不会表示有多个Url地址~~注意，这里点的是Url地址，并不是单独的参数，他就是一个/room/{room_id}这样的东西，举个栗子,/room/3242 这就表示3242号房间。 这是一个清爽的世界啊，你想想，之前的Url是什么都要，我开房，可能是/open/room/3242 我要退房可能是/exit/3242/room，我要打理房间，可能是room/3242?method=clean. 够了！这些乱七八糟的东西全够了，让世界回归清爽的本质，一间房，就是/room/3242 没有别的Url地址了。那我想要对这个资源有操作怎么办？ 这就是棒棒哒大神想出来的了，http有几种Method来着？get ,put ,post,delete，还有其他隐藏的4种。 在过去的混乱世界里，经常用的就是Get和Post。如果不是因为Get不支持大数据传输，我想连Post都会有人使用。（想像一下Roy Fielding在愤怒的对着电脑屏幕喊，Http的Method一共有八个，你们为毛只逮着Get一只羊的毛薅薅薅薅薅）。 而对资源最常见的操作是什么？CRUD，对不对，就是创建，读，更新，删除。再看Http的Method？是不是非常完美？其实也怪Fielding老爷子一开始命名不准确，如果刚开始就是把Get方法叫做Read，Put方法叫做Update，Post叫做Create这该多好。。 你用一个Get，大家又发现没什么限制没什么所谓，又很难理解Put和Post的差别，法无禁止即可为啊，呃，老爷子不要瞪我，我瞎说的。 总之，这四种方法够不够你浪？你有本事找出来更多的对资源的操作来啊，我还有4个Method没用过呢。如果这4个真的不够了，有什么问题，大不了我再重新更改http协议啊。 其实简单说，对于Rest理解到这里就够了。后续的东西，都是在这一条基础上空想出来的，比强迫症更强迫症，当然，无状态我是百分百支持的。 以上的各种表述可能不太准确，也纯属是我的意淫和各种小道资料，并未考据，但是凭良心讲，我是早就看不惯黑暗年代里的Url命名风格了，所以当时最早接触到Rest的时候，瞬间就找到了真爱，我靠，这不就是我一直想要的答案吗？但是我一直想的仅仅是命名规范，从来没有把自己的思考角度放在一个url就是一个资源，所有的操作都是对资源的更改而言的角度上啊。 所以你能理解到的程度，更多的就是在于你要弄清楚你要解决的什么问题，如果你的问题只是理解Rest，恐怕你很理解，如果你的问题是怎么解决Url混乱的问题，你反而很快能弄懂了~ HTTP方法 以下为 REST 基本架构的四个方法： GET - 用于获取数据。 PUT - 用于更新或添加数据。 DELETE - 用于删除数据。 POST - 用于添加数据。 RESTful Web Services Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序。基于 REST 架构的 Web Services 即是 RESTful。 由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端。 RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。 如果你还不明白，下面的理解都是对的，可以找到你容易理解的对号： URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。 就是用URL定位资源，用HTTP描述操作。 如何使用RESTful风格的API 一、域名： 将api部署在专用域名下： 1http://api.example.com 或者将api放在主域名下： 1http://www.example.com/api/ 二、版本： 将API的版本号放在url中。 12http://www.example.com/app/1.0/infohttp://www.example.com/app/1.2/info 三、路径： 路径表示API的具体网址。每个网址代表一种资源。 资源作为网址，网址中不能有动词只能有名词，一般名词要与数据库的表名对应。而且名词要使用复数。 错误示例： 12http://www.example.com/getGoodshttp://www.example.com/listOrders 正确示例： 123456#获取单个商品http://www.example.com/app/goods/1#获取所有商品http://www.example.com/app/goods 四、使用标准的HTTP方法： 对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有四个。 1234GET SELECT ：从服务器获取资源。POST CREATE ：在服务器新建资源。PUT UPDATE ：在服务器更新资源。DELETE DELETE ：从服务器删除资源。 示例： 1234567891011#获取指定商品的信息GET http://www.example.com/goods/ID#新建商品的信息POST http://www.example.com/goods#更新指定商品的信息PUT http://www.example.com/goods/ID#删除指定商品的信息DELETE http://www.example.com/goods/ID 五、过滤信息： 如果资源数据较多，服务器不能将所有数据一次全部返回给客户端。API应该提供参数，过滤返回结果。 实例： 12345678#指定返回数据的数量http://www.example.com/goods?limit=10#指定返回数据的开始位置http://www.example.com/goods?offset=10#指定第几页，以及每页数据的数量http://www.example.com/goods?page=2&amp;per_page=20 六、状态码： 服务器向用户返回的状态码和提示信息，常用的有： 123456789200 OK ：服务器成功返回用户请求的数据201 CREATED ：用户新建或修改数据成功。202 Accepted：表示请求已进入后台排队。400 INVALID REQUEST ：用户发出的请求有错误。401 Unauthorized ：用户没有权限。403 Forbidden ：访问被禁止。404 NOT FOUND ：请求针对的是不存在的记录。406 Not Acceptable ：用户请求的的格式不正确。500 INTERNAL SERVER ERROR ：服务器发生错误。 七、错误信息： 一般来说，服务器返回的错误信息，以键值对的形式返回。 123&#123; error: &apos;Invalid API KEY&apos;&#125; 八、响应结果： 针对不同结果，服务器向客户端返回的结果应符合以下规范。 1234567891011#返回商品列表GET http://www.example.com/goods#返回单个商品GET http://www.example.com/goods/cup#返回新生成的商品POST http://www.example.com/goods#返回一个空文档DELETE http://www.example.com/goods 九、使用链接关联相关的资源： 在返回响应结果时提供链接其他API的方法，使客户端很方便的获取相关联的信息。 十、其他： 服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 创建RESTful 首先，创建一个 json 数据资源文件 users.json，内容如下： users.json 1234567891011121314151617181920&#123; "user1" : &#123; "name" : "mahesh", "password" : "password1", "profession" : "teacher", "id": 1 &#125;, "user2" : &#123; "name" : "suresh", "password" : "password2", "profession" : "librarian", "id": 2 &#125;, "user3" : &#123; "name" : "ramesh", "password" : "password3", "profession" : "clerk", "id": 3 &#125;&#125; 基于以上数据，我们创建以下 RESTful API： 序号 URI HTTP方法 发送内容 结果 1 listUsers GET 空 显示所有用户列表 2 addUser POST JSON 字符串 添加新用户 3 deleteUser DELETE JSON 字符串 删除用户 4 :id GET 空 显示用户详细信息 1. 获取用户列表： 以下代码，我们创建了 RESTful API listUsers，用于读取用户的信息列表， server.js 文件代码如下所示： server.js 123456789101112131415var express = require('express');var app = express();var fs = require('fs');app.get('/listUsers',function(req,res)&#123; fs.readFile(__dirname+'/'+'users.json','utf8',function(err,data)&#123; console.log(data); res.end(data); &#125;);&#125;);var server = app.listen(8081,function()&#123; var host = server.address().address; var port = server.address().port; console.log('应用实例，访问地址为 http://%s:%s',host,port);&#125;); 接下来执行以下命令： 12$ node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/listUsers，结果如下所示： 1234567891011121314151617181920&#123; &quot;user1&quot; : &#123; &quot;name&quot; : &quot;mahesh&quot;, &quot;password&quot; : &quot;password1&quot;, &quot;profession&quot; : &quot;teacher&quot;, &quot;id&quot;: 1 &#125;, &quot;user2&quot; : &#123; &quot;name&quot; : &quot;suresh&quot;, &quot;password&quot; : &quot;password2&quot;, &quot;profession&quot; : &quot;librarian&quot;, &quot;id&quot;: 2 &#125;, &quot;user3&quot; : &#123; &quot;name&quot; : &quot;ramesh&quot;, &quot;password&quot; : &quot;password3&quot;, &quot;profession&quot; : &quot;clerk&quot;, &quot;id&quot;: 3 &#125;&#125; 2. 添加用户： 以下代码，我们创建了 RESTful API addUser， 用于添加新的用户数据，server.js 文件代码如下所示： addUser.js 1234567891011121314151617181920212223242526var express = require('express');var app = express();var fs = require('fs');// 添加的新用户数据var user = &#123; "user4":&#123; "name":"mohit", "password":"password4", "profession":"teacher", "id":4 &#125;&#125;app.get('/addUser',function(req,res)&#123; // 读取已存在的数据 fs.readFile(__dirname+'/'+'users.json','utf8',function(err,data)&#123; data = JSON.parse(data); data["user4"] = user["user4"]; console.log(data); res.end(JSON.stringify(data)); &#125;);&#125;);var server = app.listen(8081,function()&#123; var host = server.address().address; var port = server.address().port; console.log('应用实例，访问地址为 http://%s:%s',host,port);&#125;); 接下来执行以下命令： 12$ node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/addUser，结果如下所示： 123456789101112131415161718192021&#123; user1: &#123; name: &apos;mahesh&apos;, password: &apos;password1&apos;, profession: &apos;teacher&apos;, id: 1 &#125;, user2: &#123; name: &apos;suresh&apos;, password: &apos;password2&apos;, profession: &apos;librarian&apos;, id: 2 &#125;, user3: &#123; name: &apos;ramesh&apos;, password: &apos;password3&apos;, profession: &apos;clerk&apos;, id: 3 &#125;, user4: &#123; name: &apos;mohit&apos;, password: &apos;password4&apos;, profession: &apos;teacher&apos;, id: 4 &#125; &#125; 3. 显示用户详情： 以下代码，我们创建了 RESTful API :id（用户id）， 用于读取指定用户的详细信息，server.js 文件代码如下所示： server.js 1234567891011121314151617var express = require('express');var app = express();var fs = require('fs');app.get('/:id',function(req,res)&#123; // 首先我们读取已存在的用户 fs.readFile(__dirname+'/'+'users.json','utf8',function(err,data)&#123; data = JSON.parse(data); var user = data["user" + req.params.id]; console.log(user); res.end(JSON.stringify(user)); &#125;);&#125;);var server = app.listen(8081,function()&#123; var host = server.address().address; var port = server.address().port; console.log('应用实例，访问地址为 http://%s:%s',host,port);&#125;); 接下来执行以下命令： 12$ node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/2，结果如下所示： 123456&#123; &quot;name&quot;:&quot;suresh&quot;, &quot;password&quot;:&quot;password2&quot;, &quot;profession&quot;:&quot;librarian&quot;, &quot;id&quot;:2&#125; 4. 删除用户： 以下代码，我们创建了 RESTful API deleteUser， 用于删除指定用户的详细信息，以下实例中，用户 id 为 2，server.js 文件代码如下所示： server.js 123456789101112131415161718var express = require('express');var app = express();var fs = require("fs");var id = 2;app.get('/deleteUser',function(req,res)&#123; // First read existing users fs.readFile(__dirname+'/'+'users.json','utf8',function(err,data)&#123; data = JSON.parse(data); delete data["user" + id]; console.log(data); res.end(JSON.stringify(data)); &#125;);&#125;);var server = app.listen(8081,function()&#123; var host = server.address().address; var port = server.address().port; console.log('应用实例，访问地址为 http://%s:%s',host,port);&#125;); 接下来执行以下命令： 12$ node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/deleteUser，结果如下所示： 1234567891011&#123; user1: &#123; name: &apos;mahesh&apos;, password: &apos;password1&apos;, profession: &apos;teacher&apos;, id: 1 &#125;, user3: &#123; name: &apos;ramesh&apos;, password: &apos;password3&apos;, profession: &apos;clerk&apos;, id: 3 &#125; &#125; 如果有人遇到乱码的问题，除了不是文件读取的编码问题，可以考虑为浏览器自动为没有在 html &gt; head 中解释编码的 html 编码为本地默认编码。可以主动添加 head： 1res.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf8&apos;); 如果在同一个 server.js 里创建多个 RESTful API ， 并且 :id 放在前边， 那么它会拦截其他的请求， 比如： 12345678910111213141516171819202122232425var id = 2;// 删除用户app.get('/deleteUser', function (req, res) &#123; // 读取已存在用户 fs.readFile( __dirname + "/" + "user.json", 'utf8', function (err, data) &#123; data = JSON.parse( data ); delete data["user" + id]; console.log( data ); res.end( JSON.stringify(data)); &#125;);&#125;);// 查询用户信息 (放到前边会拦截其他请求)app.get('/:id', function(req, resp)&#123; fs.readFile(__dirname + '/user.json', 'utf-8', function(err, data)&#123; if(err)&#123; console.log(err.stack); return; &#125; data = JSON.parse(data); var user = data['user' + req.params.id]; console.log(user); resp.end(JSON.stringify(user)); &#125; );&#125;); 在浏览器中访问 http://127.0.0.1:8081/deleteUser， 控制台打印信息如下： 123应用实例，访问地址为 http://0.0.0.0:8081undefinedundefined 最后，如果还是不明白，可以看看https://phpenthusiast.com/blog/what-is-rest-api ，这篇文章的解释是比较容易理解的。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01_ubuntu_configuration]]></title>
    <url>%2F2019%2F04%2F22%2Flinux-01-ubuntu-configuration%2F</url>
    <content type="text"><![CDATA[01-Ubuntu配置 cat /etc/issue 查看内核版本 12~$ cat /etc/issueUbuntu 16.04.6 LTS \n \l sudo lsb_release -a 查看内核版本(详细信息) 12345~$ sudo lsb_release -aDistributor ID: UbuntuDescription: Ubuntu 8.04Release: 8.04Codename: hardy 查看系统版本号 1~$ cat /proc/version uname -r 查看内核版本号 12~$ uname -r 4.15.0-46-generic pwd 显示当前路径 12~$ pwd/homt/acs ls 列出目标目录中所有的子目录和文件 12345678910111213141516171819202122常用参数：-a -all：列出目录下的所有文件，包括以 . 开头的隐含文件-A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)-c 配合 -lt：根据ctime排序及显示ctime (文件状态最后更改的时间) 配合 -l：显示ctime但根据名称排序否则：根据ctime排序-C 每栏由上至下列出项目-color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是'never'、'always'或'auto'其中之一-d –directory 将目录象文件一样显示，而不是显示其下的文件-D –dired 产生适合Emacs的dired模式使用的结果-h –human-readable 以容易理解的格式列出文件大小-i –inode 印出每个文件的inode号-m 所有项目以逗号分隔，并填满整行行宽-o 类似 -l,显示文件的除组信息外的详细信息-r –reverse 依相反次序排列-R –recursive 同时列出所有子目录层-s –size 以块大小为单位列出所有文件的大小-S 根据文件大小排序-t 以文件修改时间排序-u 配合-lt:显示访问时间而且依访问时间排序 配合 -l:显示访问时间但根据名称排序 否则：根据访问时间排序-l 每行只列出一个文件 常用范例： 1234567891011121314151617181920212223242526272829例一：列出/home/peidachang文件夹下的所有文件和目录的详细资料命令：ls -l -R /home/peidachang命令：ls -lR /home/peidachang 和上面的命令形式执行的结果是完全一样的例二：列出当前目录中所有以“t”开头的目录的详细内容命令：ls -l t*例三：只列出文件下的子目录命令：ls -F /opt/soft |grep /$ 列出 /opt/soft 文件下面的子目录命令：ls -l /opt/soft | grep "^d" 列出 /opt/soft 文件下面的子目录详细情况例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面命令：ls -ltr s* 例五：列出目前工作目录下所有档案及目录;目录于名称后加"/"命令：ls -AF例七: 在ls中列出文件的绝对路径命令：ls | sed "s:^:`pwd`/:"例九：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归命令：find $PWD -maxdepth 1 | xargs ls -ld例十：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径命令： find $PWD | xargs ls -ld 例十一：指定文件时间输出格式命令：ls -tl --time-style=full-iso命令：ls -ctl --time-style=long-iso rm 删除一个目录中的一个或多个文件或目录 1234567891011121314151617实例一：删除文件file，系统会先询问是否删除命令：rm 文件名实例二：强行删除file，系统不再提示命令：rm -f log1.log实例三：删除任何.log文件；删除前逐一询问确认 命令：rm -i *.log实例四：将test1子目录及子目录中所有档案删除命令：rm -r test1实例五：rm -rf test2命令会将test2子目录及子目录中所有档案删除,并且不用一一确认命令：rm -rf test2 实例六：删除以 -f 开头的文件命令：rm -- -f code --verbose 启动VSCode 1~$ code --verbose nodejs ubuntu-make一键安装开发环境(大大精简安装开发环境的过程) 相比于Windows，Linux下安装软件已经非常简便了，一般只需要一句命令，或者通过 Ubuntu软件中心（Ubuntu Software Center）。Ubuntu Developer Tools Center“Ubuntu开发者工具中心”是在Ubuntu 14.10版本中出现的，到了15.04版本就改名为ubuntu-make了。 ubuntu-make就是旨在方便开发者安装软件开发环境的这么一个命令行工具，让你可以在命令行中输入一行简单的代码，然后敲一下回车键，即可开始安装你所指定的开发环境。 12345678910111213141516(1)安装最新版ubuntu-make# 将ubuntu-make加入apt软件仓库的列表$ sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make#升级apt的软件仓库，为了加入刚才的ubuntu-make$ sudo apt update#安装ubuntu-make$ sudo apt install ubuntu-make(2)用ubuntu-make一键安装所需开发环境$ umake --help # umake的帮助页面$ man umake # 用man（手册manuel的缩写）命令来查看umake用法$ info umake # umake的信息（info）页面#基本的安装开发环境的方法是：umake 大类 小类 例如：umake android android-studio#如果没有小类的话，那就是：umake 大类 例如：umake go# 安装Visual Studio$ umake ide visual-studio-code$ umake web visual-studio-code（会错误） 在抛出一堆要求和条件后，它会询问你是否确认安装Visual Studio Code。输入‘a’来确定， 确定之后，安装程序会开始下载并安装。安装完成后，你可以发现Visual Studio Code 图标已经出现在了Unity启动器上。点击图标开始运行！安装好后也可以直接在搜索里面找到并锁定到任务栏就可以了。 12#卸载Visual Studio Code$umake web visual-studio-code --remove 使用nodejs在ubuntu上写一个程序 12345$ mkdir myapp$ cd myapp$ npm init$ npm install express --save$ node app.js 查看ubuntu已经安装的软件 在“search your computer”中输入“ubuntu software”，然后点击“Installed”。 重启计算机 1$ sudo reboot ubuntu的垃圾箱trash 1234$ cd ~/.local/share/Trash$ cd files $ ls (files目录下会看到在Trash中删除的文件)$ sudo rm -rf /home/yourname/.local/share/Trash/ (命令行清理) ubuntu安装nodejs 12345678910111213141516(1)ubuntu源码安装nodejs#在Github上获取Node.js源码：$ sudo git clone https://github.com/nodejs/node.git#修改目录权限：$ sudo chmod -R 755 node#使用 ./configure 创建编译文件，并按照：$ cd node$ sudo ./configure$ sudo make$ sudo make install#查看 node 版本：$ node --version(2)Ubuntu apt-get命令安装$ sudo apt-get install nodejs$ sudo apt-get install npm$ sudo apt install nodejs-legacy mysql 1、查看版本 123456mysql&gt; select version(); 查看版本+-----------+| version() |+-----------+| 5.7.25 |+-----------+ Ubunru16.04安装mysql5.7 123456789101112131415161718192021222324252627282930313233343536sudo apt-get updatesudo apt-get install mysql-server此时如果提示依赖不足，那么需要运行下面命令解决依赖问题sudo apt-get install -f完成后再次运行sudo apt-get install mysql-server。如果没出现依赖问题，那么就不需要使用此命令。安装过程会提示输入数据库的登录名和密码，输入即可通过这种方式安装好之后开机自启动都已经配置好，和命令行上的环境变量，无需手动配置安装好之后会创建如下目录：数据库目录：/var/lib/mysql/ 配置文件：/usr/share/mysql（命令及配置文件） ，/etc/mysql（如：my.cnf）相关命令：/usr/bin(mysqladmin mysqldump等命令) 和/usr/sbin启动脚本：/etc/init.d/mysql（启动脚本文件mysql的目录）测试：#服务启动后端口查询sudo netstat -anp | grep mysql#服务管理#启动sudo service mysql start#停止sudo service mysql stop#服务状态sudo service mysql status#连接数据库mysql -h 127.0.0.1 -P 3306 -uroot -p123456#-h为远程IP，-P为端口号，-u为用户名，-p为密码#测试SQLshow databases;#首先使用以下命令删除MySQL服务器：sudo apt-get remove mysql-server#然后，删除随MySQL服务器自动安装的任何其他软件：sudo apt-get autoremove#卸载其他组件：sudo apt-get remove &lt;&lt;package-name&gt;&gt;#查看从MySQL APT存储库安装的软件包列表：dpkg -l | grep mysql | grep ii mysql 123456789101112131415161718192021222324252627282930313233// 创建数据库~$ mysql -u root -p(此处输入密码)mysql&gt;create database virtual_bank; -&gt;show databases; -&gt;use virtual_bank; -&gt;create table if not exists user( -&gt;id int(11) not null primary key auto_increment, -&gt;email varchar(255), -&gt;password varchar(255), -&gt;createdAt timestamp default current_timestamp, -&gt;image varchar(255), -&gt;audio varchar(255));Query OK,0 rows affected (0.04 sec)mysql&gt;show tables;+------------------------+| Tables_in_virtual_bank |+------------------------+| user |+------------------------+1 row in set (0.00 sec)mysql&gt;desc user;+-----------+--------------+------+-----+-------------------+----------------+| Field | Type | Null | Key | Default | Extra |+-----------+--------------+------+-----+-------------------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || email | varchar(255) | YES | | NULL | || password | varchar(255) | YES | | NULL | || createdAt | timestamp | YES | | CURRENT_TIMESTAMP | || image | varchar(255) | YES | | NULL | || audio | varchar(255) | YES | | NULL | |+-----------+--------------+------+-----+-------------------+----------------+6 rows in set (0.00 sec) ubuntu下解决443端口被占用 ​12１. 根据端口查找进程 sudo lsof -i:端口号２. 杀掉进程 sudo kill PID号]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13-Nodemailer]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-13-Nodemailer%2F</url>
    <content type="text"><![CDATA[13-nodemailer实现邮箱的发送、激活、注册 nodemailer 是一个简单易用的Node.js邮件发送插件. 官网地址:https://nodemailer.com. Github地址:https://github.com/nodemailer/nodemailer. 😊这次教程，我们使用nodemailer这个插件来收发邮件，这个功能非常常见，当我们注册一个账号时，肯定会有这步. 为了实现这个功能，你首先要有一个邮箱，由于需要使用SMTP方式发送，你还需要开启相关功能（在邮箱里去设置）. 一、思路： 1. 安装使用 1npm install nodemailer --save 2. 发出真实的邮件 因为QQ邮箱申请后需要10多天才可以去设置smtp😐，所以这次我们使用163邮箱来做测试. 1234567891011121314151617181920212223242526const nodemailer = require('nodemailer'); // 发送邮件的node插件let transporter = nodemailer.createTransport(&#123; service: '163', // 发送者的邮箱厂商 secureConnection: true, // SSL安全链接 auth: &#123; // 发送者的账户密码 user: 'your163mail', // 账户 pass: 'smtpCode', // smtp授权码，到邮箱设置下获取 &#125; &#125;);let mailOptions = &#123; from: '"name" &lt;your163mail&gt;', // 发送者昵称和地址 to: 'your163mail', // 接收者的邮箱地址 subject: '请在24小时内激活你的Virtual Bank账号', // 邮件主题 text: '这里是text文本:点击激活&lt;a href="http://localhost:3000/checkCode?name='+ usermess.name +'&amp;code='+ usermess.code + '"', // 邮件的text // html: html //也可以用html发送 &#125;; // 用已经定义好的transport对象来发送邮件transporter.sendMail(mailOptions, (error, info) =&gt; &#123; if (error) &#123; return console.log(error); &#125; console.log('邮件发送成功 ID：', info.messageId);&#125;); 现在邮件已经通过我们的代码发送成功，但是邮件内容只有text，还不够没美观，所以接下来我们只需要对上面的代码做一些小小的改进，就可以美化邮件的内容，做成HTML. nodemailer.js 1234567891011121314151617181920212223242526const nodemailer = require('nodemailer'); // 引入发送邮件的node插件//创建一个SMTP客户端对象（里面是SMTP客户端的配置）let transporter = nodemailer.createTransport(&#123; service: '163', // 发送者的邮箱厂商 secureConnection: true, // SSL安全链接 auth: &#123; // 发送者的账户密码 user: 'your163mail', // 账户 pass: 'smtpCode', // smtp授权码，到邮箱设置下获取 &#125; &#125;);let mailOptions = &#123; from: '"name" &lt;your163mail&gt;', // 发送者昵称和地址 to: 'your163mail', // 接收者的邮箱地址 subject: '请在24小时内激活你的Virtual Bank账号', // 邮件主题 html: fs.createReadStream(path.resolve(__dirname),'virtual_bank.html'); // 流 &#125;; // 用已经定义好的transport对象来发送邮件transporter.sendMail(mailOptions, (error, info) =&gt; &#123; if (error) &#123; return console.log(error); &#125; console.log('邮件发送成功 ID：', info.messageId);&#125;); virtual_bank.html (这里只给出框架，自己发挥想象空间去创作) 123456789&lt;!doctype html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office"&gt; &lt;head&gt; &lt;script&gt;...&lt;/script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 3. 实现邮箱的验证 在用户注册时，我们先保存用户的信息(用户名和加密后的密码)，然后生成激活码(通过username，email，当前时间等数据融合后加密)一并保存，同时将激活码发送至用户邮箱. 在自己定义的数据库中需要加三个字段：激活码 、过期时间(用来验证激活邮件是否过期)、是否已激活 (用于在激活时进行判断). 12345&#123; activeCode:String, //激活码，格式自己定义 codeExptime:Number, //过期日期，过期后不能激活 activeState:Boolean //判断是否激活（0:未激活，1：激活成功）&#125; （1）激活码:用crypto(nodejs的核心模块)来生成，并保证激活码不会重复； （2）过期时间：设为24小时，Date.now() + 24 * 3600 * 1000； （3）数据库结构设计: 用户填写资料，点击注册，插入数据成功，state字段默认是0，同时生成一个activeCode(用传过来的邮箱、用户名和当前时间加密形成)也存入数据库. 发送激活邮件，提示用户登录邮箱激活，邮箱中带有一个激活成功页的URL，URL里有两个参数（用户名和激活码）. 123456let mailOptions = &#123; from: '"name" &lt;your163mail&gt;', // 发送者昵称和地址 to: 'your163mail', // 接收者的邮箱地址 subject: '激活你的Virtual Bank账号', // 邮件主题 html: fs.createReadStream(path.resolve(__dirname),'virtual_bank.html'); // 流 &#125;; 响应激活请求：用户登录自己的邮箱，点击链接，来到处理激活业务逻辑的页面或Servlet，得到URL中的两个参数，以这两个参数为条件查询数据库里的数据. 如果有，取当前时间和之前存入数据库的激活码过期时间codeExptime作比较，看是否过期，如果过期酒删除数据库中的该记录并转到失败页面，如果没有过期就查看链接传过来的激活码与数据库字段激活码是否一致，不一致就同样删除数据库中该条记录并跳转到激活失败页面，一致则将state字段设为1 ，激活成功，跳转到激活成功页. （1）根据激活链接中的激活码查找对应的用户； （2）用户名与数据库是否匹配(若匹配)–&gt;判断激活码是否匹配(若匹配)–&gt;并判断激活码是否过期(未过期)–&gt;改变激活状态:从0变为1，激活成功； 1234&#123; title: '激活成功', content:'已成功激活，请前往&lt;a href="/account/signup"&gt;登录&lt;/a&gt;'&#125; （3）激活时间 &gt; 当前时间，激活码无效；其他任何不匹配，激活失效； 1234&#123; title: '激活失败', content:'您的激活链接无效，请重新&lt;a href="/account/signup"&gt;注册&lt;/a&gt;'&#125; 二、具体实现代码 首先，准备一个简单的测试页面. test.html 123456789101112131415&lt;body&gt; &lt;div id="main" style="margin:0 auto;width:500px;"&gt; &lt;form id="reg" action="user.action?op=reg" method="post"&gt; &lt;p&gt; E-mail：&lt;input type="text" class="input" name="email" id="email"&gt; &lt;/p&gt; &lt;p&gt; 密 码：&lt;input type="password" class="input" name="pwd" id="pwd"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="submit" class="btn" value="提交注册" &gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt; 点击提交注册，来到user.action?op=reg，注意带的参数op指我要做的操作，用于后面的Servlet做判断该做什么操作，下面的代码完成了形成激活码、过期时间等表示当前注册用户的状态的信息存入数据库并发送邮件的过程。 为了方便，Node.js 中使用 node-uuid 库来生成 UUID，简单地创建随机而且不重复的字符串，可以用来一次生成很多不同的激活码. 1234567891011121314151617181920212223242526272829303132333435363738394041424344//code.jsvar uuid = require('node-uuid');function getCode(number) &#123; var codes = []; for (var i=0; i &lt; number; i++) &#123; codes.push(uuid.v4()); &#125; return codes&#125;exports.getCode = getCode;//code_insert.jsvar mysql = require('mysql');var code = require('./code.js'); var codes = code.getCode(200); // 生成200个不同的激活码var conn = mysql.createConnection(&#123; host: 'localhost', user: 'test0002', password: 'test0002', database: 'test0002'&#125;);conn.connect(function(err)&#123; if (err) &#123; console.error(err); return; &#125;&#125;);var sql_create_table = 'create table if not exists code(id smallint auto_increment, code char(20), primary key(id))';conn.query(sql_create_table,function(err,res)&#123; if(err)&#123; console.log(err); return; &#125; for (var i=0;i&lt;codes.length;i++)&#123; var sql_insert_code = "insert into code values('code','" + codes[i] + "')"; conn.query(sql_insert_code,function(err,res)&#123; if(err)&#123; console.log(err); return; &#125; console.log(res); &#125;); &#125;&#125;);]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[work-summary-2019-4-9.md]]></title>
    <url>%2F2019%2F04%2F22%2Fwork-summary-2019-4-9-md%2F</url>
    <content type="text"><![CDATA[2019-4-9工作总结 一、Mysql数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149//通配符：%mysql&gt; show databases like &apos;virt%&apos;;mysql&gt; show tables like &apos;user%&apos;;mysql&gt; show variables like &apos;character_set%&apos;;+--------------------------+--------------------------+| Variable_name | Value |+--------------------------+--------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 |当前默认数据库的编码| character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 |服务器的编码：my.ini| character_set_system | utf8 |标识符的编码| character_sets_dir | C:\MySQL\share\charsets\ |+--------------------------+--------------------------+//删除表：drop table table_namedrop table user;drop table if exists user;//重命名表: rename table table_name01 to table_name02rename table user to user01,test to test01;//跨数据库重命名(剪切): rename table table_name01 to `database_name`.table_name02rename table user to `test01`.user01;//修改列的定义：(1)增加列：add alter table user01 add age int(11);(2)修改列：modify alter table user01 modify age varchar(40);(3)删除列：drop alter table user01 drop age;(4)重命名列：change alter table user01 change age age01 blob;修改表结构，上面是子命令，上级命令是： alter table table_name//表选项： show create table user01;先分析需要保存的实体数据拥有哪些属性，这些属性应该如何保存。//修改表选项： alter table table_name 新的表选项alter table user01 character set utf8;//修改数据库信息： alter database database_name 修改指令alter database test01 character set gbk;//创建数据(插入数据)：insert into table_name (字段列表) values (值列表)可以省略字段列表，但要求是值的顺序应该与表中的字段顺序一致。insert into user(id,email) values(1,&apos;test@163.com&apos;);//获得数据：select 字段列表 from 表名 查询条件字段列表可以用*代替，表示所有的字段；查询条件可以省略，表示所有的记录都获得。select * from user where id&gt;=72;//删除数据(不可逆)：delete from 表名 条件删除需要在逻辑上严格给条件，否则容易造成数据误操作。delete from user where id&lt;=72;//校对规则： gbk_chinese_ci(不区分大小写)； gbk_bin(按ASC码排序)；show collation;show collation like &apos;gbk%&apos;;//获得数据时按照某个字段排序：select * from user order by name;//列类型：(1)数值型：A. 整数型：a. tinyint 字节1 最小值：-128/0 最大值：127/255b. smallint 字节2 最小值：-32768/0 最大值：32767/65535c. mediumint 字节3 最小值：-8388608/0 最大值：8388607/16777215d. int 字节4 最小值：-2147483648/0 最大值：2147483647/4294967295e. bigint 字节8 最小值：-9223372036854775808/0 最大值：...字节越小，能存储的空间越小；字节越小，处理的速度越快unsigned 控制是否有正负； zerofill 前导零填充； bool布尔类型是 tinyint(1)的别名create table test(a tinyint unsigned,b tinyint);alter table test add c tinyint(2) zerofill; (01,09 ...)B. 小数型：a. float(单精度) 字节4 默认情况，精度位数为6位左右b. double(双精度) 字节8 默认情况，精度位数为16位左右c. decimal 变长（大概每9个数字用4字节存储，整数和分数分开计算） decimal(10,2)123.456 0.123456*10^3 123456 3可以利用M,D控制数值范围；可以无符号；可以zerofill；可以用科学计数法create table test(a float,b double); 精度丢失（7个左右后就不准确） 16位有效insert into test values (123456789.0123456789,123456789.0123456789)Type(M,D):M表示(总位数)所有的数值位数(不包括小数点和符号)，D表示允许的小数位数create table test(a float(5,2), 一共5位，小数2位，小数前面只能有3位（所以最大只能表示999)b double(8,3));insert into test (a) values (0.23E3);float(5,2)表示-999.99到 999.99注意： float(2)是显示宽度；float(5,2)是数值范围(2)日期时间型：a. yearb. timestampc. timed. datee. datetime(3)字符串型：a. setb. enumc. blobd. texte. varchar 可变长 varchar(M)表示允许的最大长度(可变长度)f. char 最大长度255 char(M)表示允许的字符串长度(严格限制长度)//日期事件类型(1)DATETIME: YYYY-MM-DD HH:MM:SS 存储空间8 零值为 0000-00-00 00:00:00取值从‘1000-01-01 00:00:00’到&apos;9999-12-31 23:59:59&apos;create table test(elaine datetime);insert into test values (&apos;2013-04-16 11:50:21&apos;);(2)TIMESTAMP: YYYY-MM-DD HH:MM:SS 存储空间4 零值为 0000-00-00 00:00:00取值从&apos;1970-01-01 00:00:00&apos;到&apos;2038-01-19 03:14:07&apos;create table test(elaine timestamp);insert into test values (&apos;2013-04-16 11:50:21&apos;);(3)DATE: YYYY-MM-DD 存储空间3 零值为 0000-00-00取值从&apos;1000-01-01&apos;到&apos;9999-12-31&apos;(4)TIME: HH:MM:SS 存储空间3 零值为 00:00:00取值从&apos;-838:59:59&apos;到&apos;838:59:59&apos;意义：一天中的时间；表示时间间隔，在表示间隔时可以用天来表示 D HH:MM:SS create table test(elaine time);insert into test values (&apos;23:12:11&apos;);insert into test values (&apos;231211&apos;);insert into test values (&apos;5 12:34:11&apos;);(5)YEAR: YYYY 存储空间1 零值为0000取值从&apos;1901&apos;到&apos;2155&apos; 操作语句： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465mysql&gt; select host,user from user where user=&apos;root&apos;;+-----------+------+| host | user |+-----------+------+| localhost | root |+-----------+------+mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.25 |+-----------+mysql&gt; status--------------mysql Ver 14.14 Distrib 5.7.25, for Win64 (x86_64)Connection id: 23Current database: mysqlCurrent user: root@localhostSSL: Not in useUsing delimiter: ;Server version: 5.7.25 MySQL Community Server (GPL)Protocol version: 10Connection: localhost via TCP/IPServer characterset: utf8Db characterset: utf8Client characterset: utf8Conn. characterset: utf8TCP port: 3306Uptime: 6 days 14 hours 52 min 16 secThreads: 1 Questions: 155 Slow queries: 0 Opens: 146 Flush tables: 1 Open tables: 115 Queries per second avg: 0.000--------------执行 FLUSH PRIVILEGES 语句。 这个命令执行后会重新载入授权表。mysql&gt; use user;Database changedmysql&gt; show columns from user02;+-----------+--------------+------+-----+-------------------+----------------+| Field | Type | Null | Key | Default | Extra |+-----------+--------------+------+-----+-------------------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || email | varchar(255) | YES | | NULL | || password | varchar(255) | YES | | NULL | || createdAt | timestamp | YES | | CURRENT_TIMESTAMP | || image | varchar(255) | YES | | NULL | || audio | varchar(255) | YES | | NULL | |+-----------+--------------+------+-----+-------------------+----------------+mysql&gt; show index from user02;+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| user02 | 0 | PRIMARY | 1 | id | A | 1 | NULL | NULL | | BTREE | | |+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+mysql&gt; show table status from virtual_bank;+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+| Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation | Checksum | Create_options | Comment |+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+| audios | InnoDB | 10 | Dynamic | 0 | 0 | 16384 | 0 | 0 | 0 | 1 | 2019-04-08 10:20:15 | NULL | NULL | utf8_general_ci | NULL | | || images | InnoDB | 10 | Dynamic | 2 | 8192 | 16384 | 0 | 0 | 0 | 3 | 2019-04-08 10:20:15 | 2019-04-08 12:03:56 | NULL | utf8_general_ci | NULL | | || user | InnoDB | 10 | Dynamic | 0 | 0 | 16384 | 0 | 0 | 0 | 1 | 2019-04-08 10:09:56 | NULL | NULL | utf8_general_ci | NULL | | |+--------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+ 索引： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108mysql&gt; use test;Database changed//建表测试：测试表中有五个列(c1,c2,c3,c4,c5)，均为char(1)类型且不为空。字符集为utf8(索引长度以字节数计算)mysql&gt; create table tb_test( -&gt; c1 char(1) not null, -&gt; c2 char(1) not null, -&gt; c3 char(1) not null, -&gt; c4 char(1) not null, -&gt; c5 char(1) not null) -&gt; engine innodb charset utf8; mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| tb_test |+----------------+//创建复合索引mysql&gt; alter table tb_test add index idx_c1_c2_c3_c4(c1,c2,c3,c4);Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0//插入几条测试数据mysql&gt; insert into tb_test(c1,c2,c3,c4,c5) -&gt; values(&apos;A&apos;,&apos;A&apos;,&apos;A&apos;,&apos;A&apos;,&apos;A&apos;),(&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;),(&apos;C&apos;,&apos;C&apos;,&apos;C&apos;,&apos;C&apos;,&apos;C&apos;);Query OK, 3 rows affected (0.01 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select * from tb_test;+----+----+----+----+----+| c1 | c2 | c3 | c4 | c5 |+----+----+----+----+----+| A | A | A | A | A || B | B | B | B | B || C | C | C | C | C |+----+----+----+----+----+3 rows in set (0.00 sec)//用到了索引的所有部分，其中c1,c2,c3精确匹配，c4范围查询：mysql&gt; explain select * from tb_test where c1=&apos;A&apos; and c2=&apos;A&apos; and c3=&apos;A&apos; and c4&gt;&apos;A&apos;\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_test partitions: NULL type: range //范围查询possible_keys: idx_c1_c2_c3_c4 key: idx_c1_c2_c3_c4 //用到复合索引 key_len: 12 //用到了索引的所有列，每个utf8字符占3个字节 ref: NULL rows: 1 filtered: 100.00 Extra: Using index condition //意味着没有达到索引覆盖1 row in set, 1 warning (0.01 sec)//出现ICP主要是因为我们用了select *。我们把SQL稍微改动一下，让它能达到索引覆盖mysql&gt; explain select c1,c2,c3,c4 from tb_test where c1=&apos;A&apos; and c2=&apos;A&apos; and c4&gt;&apos;A&apos; and c3=&apos;A&apos;\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_test partitions: NULL type: rangepossible_keys: idx_c1_c2_c3_c4 key: idx_c1_c2_c3_c4 key_len: 12 ref: NULL rows: 1 filtered: 100.00 Extra: Using where; Using index1 row in set, 1 warning (0.00 sec)//用到了索引的c1,c2,c3列，其中c1、c2列用于查询，c3用于排序。由于c3列没有精确匹配，导致c4列无法用到索引。mysql&gt; explain select * from tb_test where c1=&apos;A&apos; and c2=&apos;A&apos; and c4=&apos;A&apos; order by c3\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_test partitions: NULL type: ref //从表中读取匹配索引的行（查询语句不能通过索引查找到单独一行数据） //type: eq_ref 就是使用了primary key或unique key的查询，可以查到表中唯一一条记录possible_keys: idx_c1_c2_c3_c4 key: idx_c1_c2_c3_c4 //用到复合索引 key_len: 6 //用到索引的前两列 ref: const,const rows: 1 filtered: 33.33 Extra: Using index condition1 row in set, 1 warning (0.01 sec)//group by子句执行时会先排序，再分组。这条语句由于group by的顺序为c3,c2与索引顺序不匹配，所以没用到索引。group by没有用到索引，导致创建了临时表，并使用文件排序mysql&gt; explain select c2,c3 from tb_test where c1=&apos;A&apos; and c4=&apos;A&apos; group by c3,c2\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_test partitions: NULL type: refpossible_keys: idx_c1_c2_c3_c4 key: idx_c1_c2_c3_c4 //用到复合索引 key_len: 3 //只用到索引的一列 ref: const rows: 1 filtered: 33.33 Extra: Using where; Using index; Using temporary; Using filesort1 row in set, 1 warning (0.01 sec) mysql实例： 一、使用MySQL命令行将MySQL示例数据库导入到MySQL数据库服务器中 示例数据库下载地址：http://www.yiibai.com/downloads/yiibaidb.zip 1234567891011121314151617181920212223242526272829303132333435363738394041// 1.创建数据库mysql&gt; create database if not exists yiibaidb default charset utf8 collate utf8_general_ci;Query OK, 1 row affected (0.00 sec)// 2.导入数据mysql&gt; use yiibaidb;Database changedmysql&gt; source C:\MySQL\yiibaidb\yiibaidb.sql// 3.测试导入结果mysql&gt; use yiibaidb;Database changedmysql&gt; show tables;+--------------------+| Tables_in_yiibaidb |+--------------------+| customers || employees || items || offices || orderdetails || orders || payments || productlines || products || tokens |+--------------------+10 rows in set (0.00 sec)mysql&gt; select city,phone,country from offices;+---------------+------------------+-----------+| city | phone | country |+---------------+------------------+-----------+| San Francisco | +1 650 219 4782 | USA || Boston | +1 215 837 0825 | USA || NYC | +1 212 555 3000 | USA || Paris | +33 14 723 4404 | France || Beijing | +86 33 224 5000 | China || Sydney | +61 2 9264 2451 | Australia || London | +44 20 7877 2041 | UK |+---------------+------------------+-----------+7 rows in set (0.00 sec) 二、mysql示例数据库结构 MySQL示例数据库模式由以下表组成： customers: 存储客户的数据。 products: 存储汽车的数据。 productLines: 存储产品类别数据。 orders: 存储客户订购的销售订单。 orderDetails: 存储每个销售订单的订单产品数据项。 payments: 存储客户订单的付款数据信息。 employees: 存储所有员工信息以及组织结构，例如，直接上级(谁向谁报告工作)。 offices: 存储销售处数据，类似于各个分公司。 表与表之间的关系，请参考以下ER图： 三、mysql基础教程 1、查询数据 select 语句 select distinct 语句 （1）select 语句 SELECT语句的结果称为结果集，它是行列表。 1mysql&gt; select * from employees; employees表的结构：它有8列：员工人数，姓氏，名字，分机，电子邮件，办公室代码，报告，职位等。 SELECT语句控制要查看哪些列和行。例如，如果只对所有员工的名字，姓氏和职位感兴趣，或者您只想查看其职位是销售代表的每位员工的信息： 12345678select column_1,column_2,... from table_1 [inner | left | right | join table_2 on conditions]where conditionsgroup by column_1having group_conditionsorder by column_1limit offset,length; SELECT语句由以下列表中所述的几个子句组成： SELECT之后是逗号分隔列或星号(*)的列表，表示要返回所有列。 FROM指定要查询数据的表或视图。 JOIN根据某些连接条件从其他表中获取数据。 WHERE过滤结果集中的行。 GROUP BY将一组行组合成小分组，并对每个小分组应用聚合函数。 HAVING过滤器基于GROUP BY子句定义的小分组。 ORDER BY指定用于排序的列的列表。 LIMIT限制返回行的数量。 语句中的SELECT和FROM语句是必须的，其他部分是可选的。 select 语句示例： 1select lastname,firstname,jobtitle from employees; 使用星号(*)可能会返回不使用的列的数据。 它在MySQL数据库服务器和应用程序之间产生不必要的I/O磁盘和网络流量。 如果明确指定列，则结果集更可预测并且更易于管理。 使用星号(*)可能会将敏感信息暴露给未经授权的用户。 （2）select distinct 语句 从表中查询数据时，可能会收到重复的行记录。为了删除这些重复行，可以在SELECT语句中使用DISTINCT子句。 123select distinct columnsfrom table_namewhere where_conditions; 示例： 使用DISTINCT子句从employees表中选择员工的唯一姓氏(lastName)： 12345// 1.使用SELECT语句从employees表中查询员工的姓氏(lastName),有好些结果是重复的mysql&gt; select lastname from employees order by lastname;// 2.要删除重复的姓氏，要将DISTINCT子句添加到SELECT语句中,当使用DISTINCT子句时，重复的姓氏(lastname)在结果集中被消除。mysql&gt; select distinct lastname from employees order by lastname; distinct和null值： 如果列具有NULL值，并且对该列使用DISTINCT子句，MySQL将保留一个NULL值，并删除其它的NULL值，因为DISTINCT子句将所有NULL值视为相同的值。 在customers表中，有很多行的州(state)列是NULL值。 当使用DISTINCT子句来查询客户所在的州时，我们将看到唯一的州和NULL值，如下查询所示： 12345678910111213141516171819202122232425mysql&gt; select distinct state from customers;+---------------+| state |+---------------+| NULL || NV || Victoria || CA || NY || PA || CT || MA || Osaka || BC || Qubec || Isle of Wight || NSW || NJ || Queensland || Co. Cork || Pretoria || NH || Tokyo |+---------------+19 rows in set distinct在多列上的使用： 可以使用具有多个列的DISTINCT子句。 在这种情况下，MySQL使用所有列的组合来确定结果集中行的唯一性。 要从customers表中获取城市(city)和州(state)的唯一组合，可以使用以下查询： 1234select distinct state,city from customers where state is not null order by state,city; 没有DISTINCT子句，将查询获得州(state)和城市(city)的重复组合如下： distinct子句与group by子句比较 如果在SELECT语句中使用GROUP BY子句，而不使用聚合函数，则GROUP BY子句的行为与DISTINCT子句类似。 以下语句使用GROUP BY子句来选择customers表中客户的唯一state列的值： 1select state from customers group by state; 可以通过使用DISTINCT子句来实现类似的结果： 1select distinct state from customers; 一般而言，DISTINCT子句是GROUP BY子句的特殊情况。 DISTINCT子句和GROUP BY子句之间的区别是GROUP BY子句可对结果集进行排序，而DISTINCT子句不进行排序。 如果将ORDER BY子句添加到使用DISTINCT子句的语句中，则结果集将被排序，并且与使用GROUP BY子句的语句返回的结果集相同。 1select distinct state from customers order by state; distinct和聚合函数 可以使用具有聚合函数(例如SUM，AVG和COUNT)的DISTINCT子句中，在MySQL将聚合函数应用于结果集之前删除重复的行。 要计算美国客户的唯一state列的值，可以使用以下查询： 1234567mysql&gt; SELECT COUNT(DISTINCT state) FROM customers WHERE country = &apos;USA&apos;;+-----------------------+| COUNT(DISTINCT state) |+-----------------------+| 8 |+-----------------------+1 row in set distint与limit子句 如果要将DISTINCT子句与LIMIT子句一起使用，MySQL会在查找LIMIT子句中指定的唯一行数时立即停止搜索。 以下查询customers表中的前3个非空(NOT NULL)唯一state列的值。 123456789mysql&gt; SELECT DISTINCT state FROM customers WHERE state IS NOT NULL LIMIT 3;+----------+| state |+----------+| NV || Victoria || CA |+----------+3 rows in set 2、过滤数据 where and or in between like limit is null （1）where 只想从employees表中获取销售代表员工，可使用以下查询： 123select lastname,firstname,jobtitlefrom employeeswhere jobtitle=&apos;Sales Rep&apos;; 即使WHERE子句出现在语句的末尾，但MySQL会首先使用WHERE子句中的表达式来选择匹配的行。它选择具有职位名称为销售代表的行记录。 1jobtitle = 'Sales Rep'; MySQL从SELECT子句中的选择列表中选择列。 在办公室代码(officeCode)等于1中查找所有销售代表： 1select lastname,firstname,jobtitle from employees where jobtitle=&apos;Sales Rep&apos; and officeCode=1; 可用于在WHERE子句中形成过滤表达式的比较运算符： 查询使用不等于(!=)运算符来获取不是销售代表的其它所有员工： 1select lastname,firstname,jobtitle from employees where jobtitle&lt;&gt;&apos;Sales Rep&apos; （2）and AND运算符是组合两个或多个布尔表达式的逻辑运算符，只有当两个表达式求值为true时才返回true。如果两个表达式中的一个求值为false，则AND运算符返回false。 1WHERE boolean_expression_1 AND boolean_expression_2 当求值具有AND运算符的表达式时，MySQL会计算表达式的其余部分，直到可以确定结果为止。该功能称为短路求值。 选择国家是USA和CA的客户。我们在WHERE子句中使用AND运算符： 1SELECT customername, country, state FROM customers WHERE country = &apos;USA&apos; AND state = &apos;CA&apos;; 使用AND运算符，可以组合两个以上的布尔表达式。例如，以下查询返回位于美国加州的客户，并且信用额度大于100K： 12345678SELECT customername, country, state, creditlimitFROM customersWHERE country = &apos;USA&apos; AND state = &apos;CA&apos; AND creditlimit &gt; 100000; （3）or MySQL OR运算符组合了两个或两个以上布尔表达式。当任一条件为真时，返回true。 下面说明了OR运算符的语法。 1boolean_expression_1 OR boolean_expression_2 boolean_expression_1和boolean_expression_2是布尔表达式，它可能返回的结果是：true，false或NULL。 MySQL使用OR运算符进行短路评估(求值计算)。 换句话说，当MySQL可以确定结果时，MySQL会停止评估(求值计算)语句的其余部分。 当您在语句中使用多个逻辑运算符时，MySQL会在AND运算符之后再对OR运算符进行求值。 这称为运算符优先级。运算符优先级决定运算符的求值顺序。 MySQL首先对优先级较高的运算符进行求值。 1234567mysql&gt; SELECT true OR false AND false;+-------------------------+| true OR false AND false |+-------------------------+| 1 |+-------------------------+1 row in set 首先，MySQL对AND运算符求值，因此，false AND false返回false。 其次，MySQL对OR运算符求值，根据返回的false值再执行AND运算，因此true OR false返回true。 要更改评估/求值的顺序，请使用括号，例如： 1SELECT (true OR false) AND false; 要获得美国(USA)或者法国(France)的客户，请在WHERE子句中使用OR运算符，如下所示： 1select customername,country from customers where country=&apos;USA&apos; or country=&apos;France&apos;; 以下声明返回位于美国(USA)或者法国(France)，并且信用额度大于10000的客户： 1select customername,country,creditLimit from customers where (country=&apos;USA&apos; or country=&apos;France&apos;) and creditLimit&gt;10000; https://www.yiibai.com/mysql/or.html]]></content>
      <categories>
        <category>work_summary</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[work-summary-2019-4-8.md]]></title>
    <url>%2F2019%2F04%2F22%2Fwork-summary-2019-4-8-md%2F</url>
    <content type="text"><![CDATA[2019-4-8笔记 一、修改mysql配置 1、存储图像和音频文件 source: https://blog.csdn.net/haluoluo211/article/details/52080325 商品图片，用户上传的头像，其他方面的图片。目前业界存储图片有两种做法： （1）把图片直接以二进制形式存储在数据库中: 一般数据库提供一个二进制字段来存储二进制数据。比如mysql中有个blob字段。oracle数据库中是blob或bfile类型。 将读取到的图片用php程序转化成二进制形式。再结合insert into 语句插入数据表中的blob类型字段中去；从数据库取出图片展示的时候，则是直接发送图片内容。 123$row=mysql_fetch_object($result); Header( "Content-type: image/gif");echo $row-&gt;this_image; 实现代码如下： 123456$PicturePath = ‘/tmp/xxxjgjgj.jpg’;//假设这是上传的图片，php放在一个临时文件夹。脚本执行完毕后自动删除了。$imgStream = fread(fopen($PicturePath, "r");$blob_img = fread(fopen($imgStream, "r"), filesize($PicturePath));$sql =” INSERT INTO Images (this_image) VALUES ($blob_img)";//注：this_image就是数据表中一个blob字段类型的字段 取出展示图片代码： 1234$result=mysql_query("SELECT * FROM Images WHERE PicNum=$PicNum") or die("Cant perform Query"); $row=mysql_fetch_object($result); Header( "Content-type: image/gif");echo $row-&gt; this_image; 总结：处理代码感觉还真比较麻烦。其实，我从来没用过在数据库中以二进制存储图片的做法。我们用得更多的是存储图片的路径，实际图片是在磁盘上保存的(图片二进制放到数据库,把数据库的负担弄重了)。 互联网环境中大访问量，数据库速度和性能方面很重要。一般在数据库存储图片的做法比较少，更多的是将图片路径存储在数据库中，展示图片的时候只需要连接磁盘路径把图片载入进来即可。因为图片是属于大字段。一张图片可能1m到几m。 有个原则：图片尽量不要存储在数据库中(是指不要二进制形式保存到字段，而只保存图片的路径)。这样的大字段数据会加重数据库的负担，拖慢数据库，在大并发访问的情况下很重要。这是一个经验。去看看dba对数据库性能调优方面的分析都能得到这个答案的：就是图片不要存储在数据库中。 就像这个规则一样：文章分为标题、作者、添加时间、更新时间、文章内容、文章关键字。 文章内容一般是比较长的。经常使用text字段去存储。文章的内容就属于大字段。一般文章内容可以拆分到单独一个表中去。不要与文章信息存储在一张表里面。 我理解的原理是：mysql中一张表的数据是全部在一个数据文件中的。如果大字段的数据也存储在里面。程序展示列表，比如文章列表。这个时候根本不需要展示文章内容的。但是仍然会影响速度，数据库查找数据其实就是扫描那个数据文件，文件容量越小，速度就会越快(为什么单表的容量在1g-2g的时候基本上要分表了)。拆分出去到一张单独的表，就是单独的文件了。我觉得，举一反三，相互独立，分离的思想不仅在系统开发中用到，在现实生活中经常存在的。相互混合，就会造成相互影响。小巧，简洁是一种思想。 http://developer.51cto.com/art/201211/364472.htm 作者建议，三种东西永远不要放到数据库里：图片，文件，二进制数据。作者的理由是， 对数据库的读/写的速度永远都赶不上文件系统处理的速度； 数据库备份变的巨大，越来越耗时间； 对文件的访问需要穿越你的应用层和数据库层。 把图片缩略图存到数据库里？很好，那你就不能使用nginx或其它类型的轻量级服务器来处理它们了。 给自己行个方便吧，在数据库里只简单的存放一个磁盘上你的文件的相对路径，或者使用S3（备注：亚马逊云服务）或CDN之类的服务。 （2）图片存储在磁盘上，数据库字段中保存的是图片的路径。 ============================================================================== 关于mysql中的blob类型： bolb像int型那样，分为blob、MEDIUMBLOB、LONGBLOB。其实就是从小到大。blob 容量为64KB ，MEDIUMBLOB 容量为16M，LONGBLOB 容量为4G。 说实话，图片用这样子存储用得还真少。使用php函数serialize进行序列化的值，我看到有人存入这个字段中去。 mysql中blob字段存储图片有个通信大小的设置： 图片要传输给mysql存储起来，那么需要涉及到数据通信。mysql中有个配置是限制通信数据大小的。my.conf配置文件中的max_allowed_packet，mysql默认的值是1M。 好多图片尤其是原始图可能不止1m。传输的数据(也就是图片)超过这个设置大小。结果就会出错，这样明显占用与mysql交互的通信时间嘛。延长响应时长了。 直接丢个图片路径”images/xxxx”给mysql。没这么耗费资源。其实所谓的性能，最关键是数据库性能。因为随着数据库数据量增大，大部分时间耗费是在php，java等语言等待数据库返回数据的过程中耗费时间。 网站访问量大了后，具体的语言不是瓶颈，瓶颈都在数据库。用c，php，java,net都能操作mysql数据库获取数据。语言之间可能存在速度执行差异，但是其实这种差别已经很小了。至少给予用户感觉不到明显。执行相差0.0001秒用户感觉并没有明显的区别。可能说，大并发(很多用户同时访问)的时候，就会体现到差别了。其实我觉得，大并发访问是数据库瓶颈。等待数据库给予数据。没达到一定级别实在体现不了差别。数据库数据量达到一定级别。语言相差0.001s会给予用户体验上的差别。这也是为什么php很适合做web开发了。解析页面速度快(解释型语言，不需要编译)。可以用java来与数据库打交道获取数据。php不直接操作数据库，而是调用java提供的数据接口，获取数据，马上展示在页面中。这是利用了php的页面执行速度快的一个优势。 图片以二进制形式存储在数据库，有一个好处：备份的时候方便。直接备份数据库，图片也跟着备份。换句话说，迁移环境的时候是方便。而图片放在磁盘上的话，数据库中存储的只是图片路径。备份数据库后。磁盘上的图片也要跟着备份才行。 不过我觉得，备份这个好处不是很明显。图片在磁盘上，备份磁盘也没很大的事情。打包压缩也可以了。互联网环境毕竟与传统的软件开发不同，web开发比较关注网站速度。也就是数据库的速度。就像互联网开发中，有时候为了速度，用空间换时间的做法比较普遍，所以往往在设计数据库的时候并不一定遵循传统数据库设计三大范式。 数据库中保存的是图片路径的话，在web开发环境下，其实有个更好处，就是cdn加速。就是下面要进行总结的地方。 ============================================================================== 数据库中保存图片路径： 一般是这样的： 按照年月日生成路径。具体是按照年月日还是按照年月去生成路径，根据自己需要(不一定是按照日期去生成)。理解为什么要分散到多个文件夹中去才是关键，涉及到一个原理就明白了： 操作系统对单个目录的文件数量是有限制的。当文件数量很多的时候。从目录中获取文件的速度就会越来越慢。所以为了保持速度，才要按照固定规则去分散到多个目录中去。 图片分散到磁盘路径中去。数据库字段中保存的是类似于这样子的”images/2012/09/25/ 1343287394783.jpg” 原来上传的图片文件名称会重新命名保存，比如按照时间戳来生成，1343287394783. jpg。这样子是为了避免文件名重复，多个人往同一个目录上传图片的时候会出现。反正用什么样的规则命名图片，只要做到图片名称的唯一性即可。 比如网站的并发访问量大，目录的生成分得月细越好。比如精确到小时，一个小时都可以是一个文件夹。同时0.001秒有两个用户同时在上传图片(因为那么就会往同一个小时文件夹里面存图片)。因为时间戳是精确到秒的。为了做到图片名称唯一性而不至于覆盖，生成可以在在时间戳后面继续加毫秒微秒等。总结的规律是，并发访问量越大。就越精确就好了。 有个方面总结一下：为什么保存的磁盘路径，是”images/2012/09/25/1343287394783.jpg”，而不是” /images/2012/09/25/ 1343287394783.jpg”(最前面带有斜杠)：连那个斜杠都不要。这里也是做到方便以后系统扩展。 在页面中需要取出图片路径展示图片的时候： 如果是相对路径，则可以使用”./”+”images/2012/09/25/1343287394783.jpg”进行组装。 如果需要单独的域名(比如做cdn加速的时候)域名，img1.xxx.com,img2.xxx.com这样的域名，直接组装 “http://img1.xxx.com/”+”images/2012/09/25/1343287394783.jpg” 当然数据库可以在前面加斜杠/保存起来,/images/2012/09/25/ 1343287394783.jpg，但不方便统一。比如相对路径载入图片的时候，则是”.”+” /images/2012/09/25/ 1343287394783.jpg” 可能我还没体会到坏处，以后会遇到问题的。不过，遵循惯例不加斜杠” images/2012/09/25/ 1343287394783.jpg”就对了。 涉及到一个新问题：为什么大部分系统都不会域名保存进去，像这样子http://www.xxx.com/images/2012/09/25/1343287394783.jpg保存到数据库中。 了解的知识越多，越有利于我们做决定。可能就是一个“感觉区别不是很大”的影响下，去做一个决定，反而对后面是比较大的影响的。至少是增加自己的工作量了。 其实把域名保存进去，也不是什么滔天大罪的事情。但凡是经验丰富的开发人员都不会这样子做。这是一个经验积累出来的。需要了解cdn知识，什么情况下会用到cdn知识。 虽然是做开发人员，不需要关注运维和服务器之类的知识。不过了解一些就有利于理解了。 这里涉及到cdn加速。 ============================================================================== 关于cdn原理(就是内容分发网络)： cdn，我理解其本质就是为了解决距离远产生的速度问题，使用就近的服务。 从中国请求美国一台服务器上的图片。一般比较慢，因为距离这么远，网络传输是存在损耗的，距离越远，传输的时间就越长。一般会看到浏览器左下角显示：“已响应,正在传输数据…”。这不是服务器本身问题了。实际上服务器早就响应请求，把数据发给客户端，但是网络问题，就一直在传输，没传完了。 在中国，是南北距离远的问题。南北还会涉及到跨网，南方用户使用电信居多，北方用户网通居多。两个线路需要跨越，会有时间延迟。北京到广州的距离，如果直接请求。 cdn加速就是适应这个需求产生的：现在不请求美国的服务器。直接在中国安放节点(节点是比较笼统的词语，可以理解成一台服务器，也可以理解成一个机房，就是一个点嘛)，请求距离近的节点。这样子就不需要那么远的距离了。 在长沙的网站，团购以城市分站的形式。北京和长沙用的是同一套程序。服务器在长沙。北京用户访问北京站的时候,实际上需要远距离访问长沙的服务器。速度怎么都快不起来。跟服务器性能完全没关系。当时不懂这些。不清楚怎么折腾。看那本《前端优化技巧》，想办法去做js代码压缩，浏览器缓存之类的。实际上瞎折腾。不是说这些前端优化不重要，哲学上有主次矛盾之分，瓶颈在哪里就去突破哪里。没解决主要矛盾，问题并不会迎刃而解。当时也不是数据库瓶颈。如果去优化数据库。也不会明显改善。就那点数据量。根本就达不到瓶颈。哪里谈得上主要矛盾。随着后来去其他公司工作，接触一些东西，类似不找瓶颈的优化例子发生在身边好几次了，先没找到瓶颈就瞎去优化。我的同事可能是抱着多多益善的心态去做的，但主要矛盾(技术上说是瓶颈)没找到，也没改善。 当时如果没想到是距离问题。也就不会想到cdn，当时其实我根本不知道cdn服务。我只知道，google这些网站肯定有在中国部署的服务器，要不然，中国用户还去访问美国的服务器，那再好的服务器都会速度慢的。 由于自己搭建cdn环境和机房的资金比较大（需要大量的服务器），也需要人力维护。反正一般的公司弄不起，其实根本不划算。淘宝以前用商用的cdn服务，后来商用的扛不住了，就搭建了自己的cdn网。我不知道新浪有没有自己搭建，但其实我觉得跟淘宝的特点有关，店铺很多，无论是商品还是交易记录总计起来商品很多的图片，图片都是静态的部分，cdn本来就是用来做静态的(图片，css，js等)请求分发用的。 我之前在网上看到一句话，cdn网络不是一般的公司玩得起的。一般的公司自己搭建cdn网络成本高，所以就有商业的cdn提供付费租用服务，这是一项很成熟的业务，很多这样的公司，大部分全国性的互联网公司都会使用到cdn。 总结：cdn服务。对于静态内容是非常适合的。所以像商品图片，随着访问量大了后，租用cdn服务，只需要把图片上传到他们的服务器上去。 例子：北京访问长沙服务器，距离太远。我完全可以把商品图片，放到北京的云服务（我觉得现在提供给网站使用的云存储其实就是cdn，给网站提供分流和就近访问）上去。这样子北京用户访问的时候，实际上图片就是就近获取。不需要很长距离的传输。 自己用一个域名img.xxx.com来载入图片。这个域名解析到北京的云服务上去。 做法:数据库中保存的是” images/2012/09/25/1343287394783.jpg”,这些图片实际上不存储在web服务器上。上传到北京的cdn服务器上去。从数据库取出来，直接”img.xxx.com/”+” images/2012/09/25/1343287394783.jpg”如果还有多个，就命名img1.xx.com、img2.xx.com 像淘宝，凡客，亚马逊这些电子商务网站，我们看到请求的时候，下面往往会有： img1.xxx.cdn.com img2.xxx.cdn.com 其实他们保存在数据库中的是相对路径。有些是不需要在数据库保存的，缩略图可以实时访问的时候用程序生成(节省很多存储空间)。 实际上，把域名保存在数据库中，非常不利于系统迁移。一旦换个域名的话，原来保存在数据库中的是“www.abc.om/images/xxxxxx“,因为路径都在数据库中写死了。下回换个域名就用不了了。那个时候自己去写sql语句批量更新字段吧。 ============================================================================== 淘宝的图片存储： 淘宝以前使用了商用的存储。但是没法满足需求。据说，到2010年，淘宝网后端保存着286亿张图片。商用的系统系统没法满足需求的时候。他们就自己开发了一个tfs。大规模的小文件在磁盘上读取，需要磁盘磁头频繁的寻道和换道。大并发情况下和大量的操作确实很麻烦。其实借鉴了当时google公布的gfs设计论文。google有相册服务。为每个用户提供上传图片存储。 估计，google是率先实现这种小文件网络存储系统的。 有个观点比较好：对于老板们而言，往往觉得，用钱能解决的都不算问题。但问题在于，你遇到的问题，别人都没遇到过。那这个时候你就没有经验可以参考或者直接拿来使用。只有自己参考一些思路去创造技术了。 关于图片进行云存储(cdn加速)： 曾经看过这个，这个是比较适合创业公司的。价格相对便宜 https://www.upyun.com/ 介绍提到，我们在全国各地部署了55个CDN节点，500多台服务器，电信，联通，移动和教育网的4线带宽。 其实，现在的云存储本质就是一个cdn服务商。你把静态的图片上传到他提供的服务器上去(ftp方式上传或者api形式编写程序上传)。他为你做就近节点访问。 计费方式：按照流量付费，99元购买100g。怎么算流量。每次访问文件的大小累加，比如一个1m的文件，访问一次流量就加1m。 我个人理解，对于图片的量不大的情况下，使用这种云服务，好处不是节省存储空间。你自己的服务器100g的空间可能创业型公司都没用完，不是什么存储空间不够用去用云存储。以前对cdn比较模糊，这么理解，或者以为是分散网站web服务器流压力，服务器分流。这些好处是有的。但是，只要理解了cdn产生的背景和解决的关键问题后，就会明白云存储关键好处在于：给用户就近节点访问，加速。 我觉得，如果不是出于这个考虑，或者达不到这样的目的。用其他方案也完全可以替代。何必使用云存储呢？就是你无非有实力做到全国多个节点去部署服务，才需要租用cdn来帮你，毕竟他们是规模产生的效益，专注于解决这个领域。还有：腾讯云、阿里云 二、Node.js作Gateway 深入研究下node也是到了c/c++如何构建高性能的底层api，这个过程其实收获也非常大，而且这些东西不随语言的变迁而没有用，说到底语言只是工具，不用纠结太多。 语言只是个工具, 重要的是方法和思想, 前端也好, 后端也罢。 Node.js只是一个“运行环境”，本身提供很多功能，在这些功能基础上可以做多种应用开发。Node.js所直接使用的开发语言是JavaScript(ECMAScript)和C/C++，他们都不是依赖Node.js而存在的，这些语言首先是图灵完备的，其次本身具备众多特性，可以被用来做多种应用开发。 前端和后端是软件工程中的一对概念，是用来对应用程序进行分层的，软件或硬件的表示部分被称作前端，数据访问的部分被称为后端。而软件工工程上对软件系统的分层方法并不只有这一种。 从哲学上来讲，“Node.js”和“JavaScript语言”和“后端”之间不存在联系。 如下说法在逻辑学上都是错误的： “JavaScript可以用来写前端程序，所以用JavaScript的都是前端工程师” “Node.js可以用来运行后端程序，所以用Node.js的都是后端工程师” “Node.js工程师普遍会写JavaScript，而JavaScript可以用来写前端程序，所以用Node.js的都是前端工程师” “前端工程师普遍会写JavaScript，JavaScript可以用于做Node.js应用开发，而Node.js可以用来运行后端程序，所以前端工程师都是后端工程师” …… 软件开发通常对逻辑性要求非常高，如果一个软件开发工程师连上述逻辑都搞不懂的话，那么是一件多么可悲的事情。 从“前端与后端”分层思想的角度来说，前端开发需要大量前端独有的程序设计思想，后端开发也需要大量后端独有的程序设计思想，你是“前端工程师”或“后端工程师”就看你掌握哪些思想，如果你两者都掌握，那么你就既是“前端工程师”又是“后端工程师”，或者说是“全栈工程师”。 Node.js 是个运行环境而不是语言，但是现在的大环境放在那，根本不用纠结这些，说句更钻牛角尖的话，怎么解释 fs 与 buffer，所以说 Node.js 是个运行环境也不准确，所以不再纠结。 JD本身是一种很重要的声明，招聘者能够凭借JD在投简历前就能判断自己是否符合职位要求，从而避免在面试中浪费时间。只能说有些公司在招聘的时候不够专业和用心，最终结果是浪费了面试者和自己的时间与精力，甚至招到的员工其实根本在做与JD上不同的工作。 ============================================================================== 1、使用 Node.js 搭建一个 API 网关 为什么要用Node.js作为中间层 封装应用内部结构。相比起来调用指定的服务，客户端直接跟gatway交互更简单点。API Gateway提供给每一个客户端一个特定API，这样减少了客户端与服务器端的通信次数，也简化了客户端代码； 不用在所有的服务中重新实现相同的事情； 可以通过路由处理版本或后端接口，而公开的接口可以保持不变； 分解整体应用； 将共享逻辑（如身份验证）添加到网关API，可以将服务的体积变小，集中管理； 解决客户端所需要的数据的聚合级别不同，比如对在各种微服务中产生的非规范化数据实体的问题； 在 API 网关中进行数据格式的转换，而不是在所有的微服务器中分别进行实现； 处理客户端和微服务器之间的协议转换； 在 API 网关中实现速率限制，缓存以及各种可靠性功能. 客户端直接与服务器端通信的方式很少在实际中使用，通常来说，一个更好的解决办法是采用API Gateway的方式。API Gateway是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的Facet模式很像。API Gateway封装内部系统的架构，并且提供API给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。 下图展示了一个适应当前架构的API Gateway。 API Gateway负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过API Gateway，然后路由这些请求到对应的微服务。API Gateway将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在web协议与内部使用的非Web友好型协议间进行转换，如 HTTP协议、WebSocket协议。 API Gateway可以提供给客户端一个定制化的API。它暴露一个粗粒度API给移动客户端。以产品最终页这个使用场景为例。API Gateway提供一个服务提供点（/productdetails?productid=xxx）使得移动客户端可以在一个请求中检索到产品最终页的全 部数据。API Gateway通过调用多个服务来处理这一个请求并返回结果，涉及产品信息、推荐、评论等。 一个很好的API Gateway例子是 Netfix API Gateway。Netflix流服务提供数百个不同的微服务，包括电视、机顶盒、智能手机、游戏系统、平板电脑等。起初，Netflix视图提供一个 适用全场景的 API。但是，他们发现这种形式不好用，因为涉及到各式各样的设备以及它们独特的需求。现在，他们采用一个API Gateway来提供容错性高的API，针对不同类型设备有相应代码。事实上，一个适配器处理一个请求平均要调用6到8个后端服务。Netflix API Gateway每天处理数十亿的请求。 API Gateway的优点和缺点 如你所料，采用API Gateway也是优缺点并存的。API Gateway的一个最大好处是封装应用内部结构。相比起来调用指定的服务，客户端直接跟gatway交互更简单点。API Gateway提供给每一个客户端一个特定API，这样减少了客户端与服务器端的通信次数，也简化了客户端代码。 API Gateway也有一些缺点。它是一个高可用的组件，必须要开发、部署和管理。还有一个问题，它可能成为开发的一个瓶颈。开发者必须更新API Gateway来提供新服务提供点来支持新暴露的微服务。更新API Gateway时必须越轻量级越好。否则，开发者将因为更新Gateway而排队列。但是，除了这些缺点，对于大部分的应用，采用API Gateway的方式都是有效的。 外部客户端访问微服务架构中的服务时，服务端会对认证和传输有一些常见的要求。API 网关提供共享层来处理服务协议之间的差异，并满足特定客户端（如桌面浏览器、移动设备和老系统）的要求。 （1）微服务和消费者 微服务是面向服务的架构，团队可以独立设计、开发和发布应用程序。它允许在系统各个层面上的技术多样性，团队可以在给定的技术难题中使用最佳语言、数据库、协议和传输层，从而受益。例如，一个团队可以使用 HTTP REST 上的 JSON，而另一个团队可以使用 HTTP/2 上的 gRPC 或 RabbitMQ 等消息代理。 在某些情况下使用不同的数据序列化和协议可能是强大的，但要使用我们的产品的客户可能有不同的需求。该问题也可能发生在具有同质技术栈的系统中，因为客户可以从桌面浏览器通过移动设备和游戏机到遗留系统。一个客户可能期望 XML 格式，而另一个客户可能希望 JSON 。在许多情况下，您需要同时支持它们。 当客户想要使用您的微服务时，您可以面对的另一个挑战来自于通用的共享逻辑（如身份验证），因为您不想在所有服务中重新实现相同的事情。 总结：我们不想在我们的微服务架构中实现我们的内部服务，以支持多个客户端并可以重复使用相同的逻辑。这就是 API 网关出现的原因，其作为共享层来处理服务协议之间的差异并满足特定客户端的要求。 （2）什么是 API 网关？ API 网关是微服务架构中的一种服务，它为客户端提供共享层和 API，以便与内部服务进行通信。API 网关可以进行路由请求、转换协议、聚合数据以及实现共享逻辑，如认证和速率限制器。 您可以将 API 网关视为我们的微服务世界的入口点。 我们的系统可以有一个或多个 API 网关，具体取决于客户的需求。例如，我们可以为桌面浏览器、移动应用程序和公共 API 提供单独的网关。 Node.js 用于前端团队的 API 网关 由于 API 网关为客户端应用程序（如浏览器）提供了功能，它可以由负责开发前端应用程序的团队实施和管理。 这也意味着用哪种语言实现 API Gateway 应由负责特定客户的团队选择。由于 JavaScript 是开发浏览器应用程序的主要语言，即使您的微服务架构以不同的语言开发，Node.js 也可以成为实现 API 网关的绝佳选择。 Netflix 成功地使用 Node.js API 网关及其 Java 后端来支持广泛的客户端 - 了解更多关于它们的方法阅读 The “Paved Road” PaaS for Microservices at Netflix 这篇文章 （3）API 网关功能 我们之前讨论过，可以将通用共享逻辑放入您的 API 网关，本节将介绍最常见的网关职责。 路由和版本控制 我们将 API 网关定义为您的微服务的入口点。在您的网关服务中，您可以指定从客户端路由到特定服务的路由请求。您甚至可以通过路由处理版本或更改后端接口，而公开的接口可以保持不变。您还可以在您的 API 网关中定义与多个服务配合的新端点。 API 网关作为微服务入口点 网关设计的升级 API 网关方法也可以帮助您分解您的整体应用程序。在大多数情况下，在微服务端重构一个系统不是一个好主意也是不可能的，因为我们需要在重构期间为业务发送新的以及原有的功能。 在这种情况下，我们可以将代理或 API 网关置于我们的整体应用程序之前，将新功能作为微服务实现，并将新端点路由到新服务，同时通过原有的路由服务旧端点。这样以后，我们也可以通过将原有功能转变为新服务来分解整体。 随着网关设计的升级，我们可以实现整体架构到微型服务的平滑过渡。 API 网关设计的升级 认证 大多数微服务基础设施需要进行身份验证。将共享逻辑（如身份验证）添加到 API 网关可以帮助您保持您的服务的体积变小以及可以集中管理域。 在微服务架构中，您可以通过网络配置将您的服务保护在 DMZ （保护区）中，并通过 API 网关向客户公开。该网关还可以处理多个身份验证方法。例如，您可以同时支持基于 cookie 和 token 的身份验证。 具有认证功能的 API 网关 数据汇总 在微服务架构中，可能客户端所需要的数据的聚合级别不同，比如对在各种微服务中产生的非规范化数据实体。在这种情况下，我们可以使用我们的 API 网关来解决这些依赖关系并从多个服务收集数据。 在下图中，您可以看到 API 网关如何将用户和信用信息作为一个数据返回给客户端。请注意，这些数据由不同的微服务所拥有和管理。 序列化格式转换 我们需要支持客户端不同的数据序列化格式这样子的需求可能会发生。 想象一下我们的微服务使用 JSON 的情况，但我们的客户只能使用 XML APIs。在这种情况下，我们可以在 API 网关中把 JSON 转换为 XML，而不是在所有的微服务器中分别进行实现。 协议转换 微服务架构允许多通道协议传输从而获取多种技术的优势。然而，大多数客户端只支持一个协议。在这种情况下，我们需要转换客户端的服务协议。 API 网关还可以处理客户端和微服务器之间的协议转换。在下一张图片中，您可以看到客户端希望通过 HTTP REST 进行的所有通信，而内部的微服务使用 gRPC 和 GraphQL 。 速率限制和缓存 在前面的例子中，您可以看到我们可以把通用的共享逻辑（如身份验证）放在 API 网关中。除了身份验证之外，您还可以在 API 网关中实现速率限制，缓存以及各种可靠性功能。 超负荷的 API 网关 在实现您的 API 网关时，您应避免将非通用逻辑（如特定数据转换）放入您的网关。 服务应该始终拥有他们的数据域的全部所有权。构建一个超负荷的 API 网关，让微服务团队来控制，这违背了微服务的理念。 这就是为什么你应该关注你的 API 网关中的数据聚合 - 你应该避免它有大量逻辑甚至可以包含特定的数据转换或规则处理逻辑。 始终为您的 API 网关定义明确的责任，并且只包括其中的通用共享逻辑。 实现一个API Gateway 既然我们已经知道了采用API Gateway的动机和优缺点，下面来看在设计它时需要考虑哪些事情。 对于大多数应用，API Gateway的性能和可扩展性也是非常重要的。因此，创建一个支持同步、非阻塞I/O的API Gateway是有意义的。已经有不同的技术可以用来实现一个可扩展的API Gateway。在JVM上，采用基于NIO技术的框架，如Netty，Vertx，Spring Reactor或者JBoss Undertow。Node.js是一个非JVM的流行平台，它是一个在Chrome的JavaScript引擎基础上建立的平台。一个可选的方案是 NGINX Plus。NGINX Plus提供一个成熟的、可扩展的、高性能web服务器和反向代理，它们均容易部署、配置和二次开发。NGINX Plus可以管理授权、权限控制、负载均衡、缓存并提供应用健康检查和监控。 采用反应性编程模型 对于有些请求，API Gateway可以通过直接路由请求到对应的后端服务上的方式来处理。对于另外一些请求，它需要调用多个后端服务并合并结果来处理。对于一些请求，例如产品最终页面请求，发给后端服务的请求是相互独立的。为了最小化响应时间，API Gateway应该并发的处理相互独立的请求。但是，有时候请求之间是有依赖的。API Gateway可能需要先通过授权服务来验证请求，然后在路由到后端服务。类似的，为了获得客户的产品愿望清单，需要先获取该用户的资料，然后返回清单上 产品的信息。这样的一个API 组件是 Netflix Video Grid。 利用传统的同步回调方法来实现API合并的代码会使得你进入回调函数的噩梦中。这种代码将非常难度且难以维护。一个优雅的解决方案是采用反应性编程模式来实现。类似的反应抽象实现有Scala的 Future，Java8的 CompletableFuture和JavaScript的 Promise。基于微软.Net平台的有 Reactive Extensions(Rx)。Netflix为JVM环境创建了RxJava来使用他们的API Gateway。同样地，JavaScript平台有RxJS，可以在浏览器和Node.js平台上运行。采用反应编程方法可以帮助快速实现一个高效的API Gateway代码。 服务调用 一个基于微服务的应用是一个分布式系统，并且必须采用线程间通信的机制。有两种线程间通信的方法。一种是采用同步机制，基于消息的方法。这类的实现方法有JMS和AMQP。另外的，例如Zeromq属于服务间直接通信。还有一种线程间通信采用异步机制，例如Thrift和 HTTP。事实上一个系统会同时采用同步和异步两种机制。由于它的实现方式有很多种，因此API Gateway就需要支持多种通信方式。 服务发现 API Gateway需要知道每一个微服务的IP和端口。在传统应用中，你可能会硬编码这些地址，但是在现在云基础的微服务应用中，这将是个简单的问题。基础服务通常会采用静态地址，可以采用操作系统环境变量来指定。但是，探测应用服务的地址就没那么容易了。应用服务通常动态分配地址和端口。同样的，由于扩展或者升级，服务的实例也会动态的改变。因此，API Gateway需要采用系统的服务发现机制，要么采用 服务端发现，要么是 客户端发现。后续的一篇文章将会更详细的介绍这部分。如果采用客户端发现服务，API Gateway必须要去查询 服务注册处，也就是微服务实例地址的数据库。 处理部分失败 在实现API Gateway过程中，另外一个需要考虑的问题就是部分失败。这个问题发生在分布式系统中当一个服务调用另外一个服务超时或者不可用的情况。API Gateway不应该被阻断并处于无限期等待下游服务的状态。但是，如何处理这种失败依赖于特定的场景和具体服务。例如，如果是在产品详情页的推荐服务模块无响应，那么API Gateway应该返回剩下的其他信息给用户，因为这些信息也是有用的。推荐部分可以返回空，也可以返回固定的顶部10个给用户。但是，如果是产品信息服 务无响应，那么API Gateway就应该给客户端返回一个错误。 在缓存有效的时候，API Gateway应该能够返回缓存。例如，由于产品价格变化并不频繁，API Gateway在价格服务不可用时应该返回缓存中的数值。这类数据可以由API Gateway自身来缓存，也可以由Redis或Memcached这类外部缓存实现。通过返回缓存数据或者默认数据，API Gateway来确保系统错误不影响到用户体验。 Netflix Hystrix对于实现远程服务调用代码来说是一个非常好用的库。Hystrix记录那些超过预设定的极限值的调用。它实现了 circuit break模 式，使得可以将客户端从无响应服务的无尽等待中停止。如果一个服务的错误率超过预设值，Hystrix将中断服务，并且在一段时间内所有请求立刻失效。 Hystrix可以为请求失败定义一个fallback操作，例如读取缓存或者返回默认值。如果你在用JVM，就应该考虑使用Hystrix。如果你采用 的非JVM环境，那么应该考虑采用类似功能的库。 总结 对于大多数微服务基础的应用，实现一个API Gateway都是有意义的，它就像是进入系统的一个服务提供点。API Gateway负责请求转发、请求合成和协议转换。它提供给应用客户端一个自定义的API。API Gateway可以通过返回缓存或者默认值的方式来掩盖后端服务的错误。在本系列的下一篇文章中，我们将讨论服务间的通信问题。 （4）Node.js API 网关 在 Node.js 中，您可以使用 http-proxy 软件包简单地代理对特定服务的请求，也可以使用更多丰富功能的 express-gateway 来创建 API 网关。 在我们的第一个 API 网关示例中，我们在将代码委托给 user 服务之前验证请求。 1234567891011121314const express = require('express')const httpProxy = require('express-http-proxy')const app = express()const userServiceProxy = httpProxy('https://user-service')// 身份认证app.use((req, res, next) =&gt; &#123;// TODO: 身份认证逻辑 next()&#125;)// 代理请求app.get('/users/:userId', (req, res, next) =&gt; &#123; userServiceProxy(req, res, next)&#125;) 另一种示例可能是在您的 API 网关中发出新的请求，并将响应返回给客户端： 12345678910const express = require('express')const request = require('request-promise-native')const app = express()// 解决: GET /users/meapp.get('/users/me', async (req, res) =&gt; &#123; const userId = req.session.userId const uri = `https://user-service/users/$&#123;userId&#125;` const user = await request(uri) res.json(user)&#125;) Node.js API 网关总结 API 网关提供了一个共享层，以通过微服务架构来满足客户需求。它有助于保持您的服务小而专注。您可以将不同的通用逻辑放入您的 API 网关，但是您应该避免 API 网关的过度使用，因为很多逻辑可以从服务团队中获得控制。]]></content>
      <categories>
        <category>work_summary</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01_common_commands]]></title>
    <url>%2F2019%2F04%2F22%2Fhexo-01-common-commands%2F</url>
    <content type="text"><![CDATA[01-hexo常用命令手册 生成hexo静态博客 新建elaine文件夹 hexo init npm install hexo g hexo s #本地预览 与Github关联 Github上新建 github名字.github.io 的仓库 在elaine_config.yml中设置：将type设置为git（替换成你自己的信息），然后 hexo g、hexo d 1234deploy: type: git repo: git@github.com:ElaineXHZhong/ElaineXHZhong.github.io.git branch: master 用next主题： 将next的解压缩文件放在elaine\themes下面 将elaine下的_config.yml文件修改： theme: next 用live2d动画： 将elaine下的_config.yml文件添加： 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-tororo display: position: right width: 150 height: 300 mobile: show: true 添加菜单项： 在hexo下运行git: hexo n page ‘about’，（会在source下面出现about文件夹，修改里面的.md文件） 修改themes下的next里的_config.yml文件，添加： 123menu: home: / || home about: /about/ || user 修改： 1language: zh-Hans 修改themes下的next下的languages下的zh-Hans.yml： 123menu: home: 首页 about: 关于 添加分类： hexo n page ‘categories’（source下出现categories文件夹，修改里面的.md文件）：（添加type: “categories”） 123title: categoriesdate: 2019-04-20 23:39:03type: "categories" 以后每次 hexo n articleName（source下面的_posts会出现相应文章），在文章.md文件中编辑： 12345// 方式1categories: 编程// 方式2categories: -编程 然后修改elaine下的_config.yml： 12345# Category &amp; Tagdefault_category: uncategorizedcategory_map: 编程: programming # 分类名称：访问路径tag_map: 就可以把该文章分类到‘programming’类； 标签的设置也是一样的： 12345678910---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端tags:- jQuery- 表格- 表单验证--- 至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 两个的设置几乎一模一样！ 所以我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了： 1234title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: tags: 异地同步博客：决定博客显示内容的只有一个Public目录，而public目录又是可以动态生成的（hexo g，根据_config.yml，source目录和themes目录下的文件生成），只要在不同电脑上同步可以生成Public目录的文件即可。以下文件以及目录是必须要同步的： source themes _config.yml db.json package.json .deploy_git]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-world]]></title>
    <url>%2F2019%2F04%2F22%2Fhexo-00-hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: [Deployment](]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12_Router]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-12-Router%2F</url>
    <content type="text"><![CDATA[12- Node.js路由封装 01router.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445//引入http模块var http=require('http');var url=require('url');var ejs=require('ejs');var fs=require('fs');//路由:指的就是针对不同请求的 URL，处理不同的业务逻辑。http.createServer(function(req,res)&#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); //获取get 还是post请求 var method=req.method.toLowerCase(); //console.log(method); var pathname=url.parse(req.url,true).pathname; if(pathname=='/login')&#123; /*显示登录页面*/ ejs.renderFile('views/form.ejs',&#123; &#125;,function(err,data)&#123; res.end(data); &#125;) &#125;else if(pathname=='/dologin' &amp;&amp;method=='get')&#123; /*执行登录的操作*/ //get获取数据 console.log(url.parse(req.url,true).query); res.end('dologin'); &#125;else if(pathname=='/dologin' &amp;&amp;method=='post')&#123; /*执行登录的操作*/ var postStr=''; req.on('data',function(chunk)&#123; postStr+=chunk; &#125;) req.on('end',function(err,chunk)&#123; //res.end(postStr); console.log(postStr); fs.appendFile('login.txt',postStr+'\n',function(err)&#123; if(err)&#123; console.log(err); return; &#125; console.log('写入数据成功'); &#125;) res.end("&lt;script&gt;alert('登录成功');history.back();&lt;/script&gt;") &#125;) &#125;else&#123; ejs.renderFile('views/index.ejs',&#123; &#125;,function(err,data)&#123; res.end(data); &#125;) &#125;&#125;).listen(8001); 02router.js 123456789101112131415161718//引入http模块var http=require('http');var url=require('url');var model=require('./model/model.js');//model['login']('111','22');////路由:指的就是针对不同请求的 URL，处理不同的业务逻辑。http.createServer(function(req,res)&#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); var pathname=url.parse(req.url).pathname.replace('/',''); if(pathname!='favicon.ico') &#123; try &#123; model[pathname](req, res); &#125; catch (err) &#123; model['home'](req, res); &#125; &#125; //console.log(pathname);&#125;).listen(8001); 03demo.js 12345678910111213141516171819202122//index.jsvar route = require('./model/http-route.js');var app = route();var http = require('http');var server = http.createServer(app);app.get('/', function (req, res) &#123; res.send('é¦–é¡µ');&#125;);app.get('/login', function (req, res) &#123; res.send('login');&#125;);app.get('/register', function (req, res) &#123; res.send('register');&#125;);app.post('/test', function (req, res) &#123; console.log('POST', req.query); res.send(req.query);&#125;);server.listen(8080, function () &#123; console.log('listen ' + server.address().port);&#125;);]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11_Get_Post]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-11-Get-Post%2F</url>
    <content type="text"><![CDATA[11-GET、POST、EJS、静态文件托管 一、静态文件托管 和静态web服务是一样的，只不过对静态 web 服务器做一个封装。 二、路由 官方解释： 路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成 的，涉及到应用如何响应客户端对某个网站节点的访问。 非官方解释： 路由指的就是针对不同请求的 URL，处理不同的业务逻辑。 三、认识EJS模块引擎 我们学的 EJS 是后台模板，可以把我们数据库和文件读取的数据显示到 Html 页面上面。它 是一个第三方模块，需要通过 npm 安装。 1npm install ejs –save 123ejs.renderFile(filename, data, options, function(err, str)&#123; // str =&gt; Rendered HTML string &#125;); EJS 常用标签 &lt;% %&gt;流程控制标签 &lt;%= %&gt;输出标签（原文输出 HTML 标签） &lt;%- %&gt;输出标签（HTML 会被浏览器解析） 123456&lt;a href="&lt;%= url %&gt;"&gt;&lt;img src="&lt;%= imageURL %&gt;" alt=""&gt;&lt;/a&gt;&lt;ul&gt;&lt;ul&gt; &lt;% for(var i = 0 ; i &lt; news.length ; i++)&#123; %&gt; &lt;li&gt;&lt;%= news[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; 四、Get、Post 超文本传输协议（HTTP）的设计目的是保证客户端机器与服务器之间的通信。 在客户端和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。 GET - 从指定的资源请求数据。（一般用于获取数据） POST - 向指定的资源提交要被处理的数据。（一般用于提交数据） 123获取 GET 传值： var urlinfo= url .parse(req.url,true); urlinfo.query(); 123456789101112获取 POST 传值： var postData = ''; // 数据块接收中 req.on('data', function (postDataChunk) &#123; postData += postDataChunk; &#125;); // 数据接收完毕，执行回调函数 req.on('end', function () &#123; try &#123; postData = JSON.parse(postData); &#125;catch(e)&#123; &#125; req.query = postData; console.log(querystring .parse(postData)); &#125;); 例子： 00services1.js 123456789//引入http模块var http=require('http');//引入扩展名的方法是在文件里面获取到的。var router=require('./model/router.js');//console.log(mimeModel.getMime('.css')); //获取文件类型http.createServer(function(req,res)&#123; //router.statics(req,res,'static'); console.log(req.url);&#125;).listen(8001); 00services2.js 12345678910111213141516//引入http模块var http=require('http');var url=require('url');//路由:指的就是针对不同请求的 URL，处理不同的业务逻辑。http.createServer(function(req,res)&#123; var pathname=url.parse(req.url).pathname; if(pathname=='/login')&#123; res.end('login'); &#125;else if(pathname=='/register')&#123; res.end('register'); &#125;else if(pathname=='/order')&#123; res.end('order'); &#125;else&#123; res.end('index'); &#125;&#125;).listen(8001); 00services3.js 123456789101112131415161718192021222324252627282930313233//引入http模块var http=require('http');var url=require('url');var ejs=require('ejs');//路由:指的就是针对不同请求的 URL，处理不同的业务逻辑。http.createServer(function(req,res)&#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); var pathname=url.parse(req.url).pathname; if(pathname=='/login')&#123; var data='你好我是后台数据'; var list=[ '1111', '2222', '3333', ]; //把数据库的数据渲染到模板上面 ejs.renderFile('views/login.ejs',&#123; msg:data, list:list &#125;,function(err,data)&#123; res.end(data); &#125;) &#125;else&#123; var msg='这是注册页面，也是注册的路由'; var h="&lt;h2&gt;这是一个h2&lt;/h2&gt;" ejs.renderFile('views/register.ejs',&#123; msg:msg, h:h &#125;,function(err,data)&#123; res.end(data); &#125;) &#125;&#125;).listen(8001); get_post.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445//引入http模块var http=require('http');var url=require('url');var ejs=require('ejs');var fs=require('fs');//路由:指的就是针对不同请求的 URL，处理不同的业务逻辑。http.createServer(function(req,res)&#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); //获取get 还是post请求 var method=req.method.toLowerCase(); //console.log(method); var pathname=url.parse(req.url,true).pathname; if(pathname=='/login')&#123; /*显示登录页面*/ ejs.renderFile('views/form.ejs',&#123; &#125;,function(err,data)&#123; res.end(data); &#125;) &#125;else if(pathname=='/dologin' &amp;&amp;method=='get')&#123; /*执行登录的操作*/ //get获取数据 console.log(url.parse(req.url,true).query); res.end('dologin'); &#125;else if(pathname=='/dologin' &amp;&amp;method=='post')&#123; /*执行登录的操作*/ var postStr=''; req.on('data',function(chunk)&#123; postStr+=chunk; &#125;) req.on('end',function(err,chunk)&#123; //res.end(postStr); console.log(postStr); fs.appendFile('login.txt',postStr+'\n',function(err)&#123; if(err)&#123; console.log(err); return; &#125; console.log('写入数据成功'); &#125;) res.end("&lt;script&gt;alert('登录成功');history.back();&lt;/script&gt;") &#125;) &#125;else&#123; ejs.renderFile('views/index.ejs',&#123; &#125;,function(err,data)&#123; res.end(data); &#125;) &#125;&#125;).listen(8001); login.txt 12username=zhangsan&amp;password=123username=zhangsan222&amp;password=3333 model/router.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//fs模块var fs=require('fs');//path模块var path=require('path'); /*nodejs自带的模块*///url模块var url=require('url');//获取文件类型的方法 私有function getMime(extname,callback)&#123; /*获取后缀名的方法*/ fs.readFile('./mime.json',function(err,data)&#123; if(err)&#123; console.log('mime.json文件不存在'); return false; &#125; //console.log(data.toString()); var Mimes=JSON.parse(data.toString()); var result= Mimes[extname] || 'text/html'; callback(result) &#125;)&#125;exports.statics=function(req,res,staticpath)&#123; var pathname=url.parse(req.url).pathname; /*获取url的值*/ if(pathname=='/')&#123; pathname='/index.html'; /*默认加载的首页*/ &#125; //获取文件的后缀名 var extname=path.extname(pathname); if(pathname!='/favicon.ico')&#123; /*过滤请求favicon.ico*/ //console.log(pathname); //文件操作获取 static下面的index.html fs.readFile(staticpath+'/'+pathname,function(err,data)&#123; if(err)&#123; /*么有这个文件*/ console.log('404'); fs.readFile(staticpath+'/404.html',function(error,data404)&#123; if(error)&#123; console.log(error); &#125; res.writeHead(404,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); res.write(data404); res.end(); /*结束响应*/ &#125;) &#125;else&#123; /*返回这个文件*/ getMime(extname,function(mime)&#123; res.writeHead(200,&#123;"Content-Type":""+mime+";charset='utf-8'"&#125;); res.write(data); res.end(); /*结束响应*/ &#125;); &#125; &#125;) &#125;&#125;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10_Callback_Event]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-10-Callback-Event%2F</url>
    <content type="text"><![CDATA[10-Nodejs回调和事件驱动 一、 Node.js的单线程、非阻塞 I/O、事件驱动 在 Java、PHP 或者.net 等服务器端语言中，会为每一个客户端连接创建一个新的线程。 而每个线程需要耗费大约 2MB 内存。也就是说，理论上，一个 8GB 内存的服务器可以同时 连接的最大用户数为 4000 个左右。要让Web应用程序支持更多的用户，就需要增加服务器 的数量，而 Web 应用程序的硬件成本当然就上升了。 Node.js 不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了， 就触发一个内部事件，通过非阻塞 I/O、事件驱动机制，让 Node.js 程序宏观上也是并行的。 使用 Node.js，一个 8GB 内存的服务器，可以同时处理超过4 万用户的连接。 二、Node.js回调处理异步 错误的写法： 123456789function getData ()&#123; // 模拟请求数据 var result=''; setTimeout (function()&#123; result='这是请求到的数据' &#125;,200); return result; &#125; console .log( getData ()); /* 异步导致请求不到数据 */ 正确的写法： 1234567891011function getData (callback)&#123; // 模拟请求数据 var result=''; setTimeout (function()&#123; result='这是请求到的数据'; callback(result); &#125;,200); &#125; getData (function( data )&#123; console.log(data) ; &#125;) 错误的写法：(非阻塞) 12345678910111213141516171819202122var fs=require('fs');//非阻塞io//console.log('1');////fs.readFile('mime.json',function(err,data)&#123;// //console.log(data);// console.log('2');//&#125;)////console.log('3');function getMime()&#123; //1 fs.readFile('mime.json',function(err,data)&#123; //console.log(data.toString()); return data;//3 &#125;) //2 //return '123';&#125;console.log(getMime()); /*有问题*/ 正确的写法：(回调函数) 1234567891011var fs=require('fs');function getMime(callback)&#123; fs.readFile('mime.json',function(err,data)&#123; //console.log(data.toString()); //return data; callback(data); &#125;)&#125;getMime(function(result)&#123; console.log(result.toString());&#125;) 三、Node.js events 模块处理异步 Node.js 事件循环: Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件。 1234567891011// 引入events模块 var events = require ('events'); var EventEmitter =new events.EventEmitter(); /* 实例化事件对象 */ // 广播和接收广播(也就是事件驱动)EventEmitter.on('to_parent',function()&#123; // 监听to_parent的广播 //on监听一个广播 console.log('接收到了to_parent这个广播事件'); &#125;) setTimeout(function()&#123; // 过1秒后触发一个定时器(一个广播) console.log('开始广播了...'); EventEmitter.emit('to_parent','你要发送的数据'); /* 发送广播 */ //emit触发一个广播&#125;,1000) 程序流程：进来后监听to_parent这个广播（还没有执行），等到1秒后emit广播了以后，它才会监听到这个事件。可以在on里面console.log(data)来得到要发送的数据。 12345678var events = require('events');var EventEmitter = new events.EventEmitter();EventEmitter.on('to_parent',function(data)&#123; console.log(data); // 这个data就是下面emit发送的数据&#125;)setTimeout(function()&#123; EventEmitter.emit('to_parent','要发送的数据');&#125;) 注意看下面广播事件的顺序： 12345678910111213141516171819var events=require('events');var EventEmitter=new events.EventEmitter();EventEmitter.on('to_mime',function(data)&#123; console.log(data);&#125;)//监听to_parent的广播EventEmitter.on('to_parent',function(data)&#123; //console.log('接收到了这个广播事件'); console.log(data); EventEmitter.emit('to_mime','给mime发送的数据')&#125;)setTimeout(function()&#123; console.log('开始广播...'); //广播to_parent事件 EventEmitter.emit('to_parent','发送的数据')&#125;,1000);//开始广播...//发送的数据//给mime发送的数据 首先，开始广播，打印出’开始广播…’，因为首先监听广播，它只监听但是不会执行回调函数；当通过EventEmitter.emit()广播以后，EventEmitter.on()就接收到了广播，才会触发里面的回调函数；在回调函数里又广播了一次 。 Node.js事件驱动获取数据： 12345678910111213var fs=require('fs');var events=require('events');var EventEmitter=new events.EventEmitter();function getMime(callback)&#123; fs.readFile('mime.json',function(err,data)&#123; EventEmitter.emit('data',data) &#125;)&#125;getMime();/*执行方法*///监听广播数据EventEmitter.on('data',function(mime)&#123; console.log(mime.toString());&#125;)]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09_Create_Server]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-09-Create-Server%2F</url>
    <content type="text"><![CDATA[09-利用http模块、url模块、path模块创建一个web服务器 一、Node.js 创建的第一个应用 123456789101112//1. 引入http 模块 const http = require ('http'); //2. 用http模块创建服务 http.createServer(function(req,res)&#123; // 发送HTTP头部 // HTTP状态值:200 : OK // 设置HTTP头部，状态码是200，文件类型是html，字符集是utf-8 res.writeHead(200,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); res.write('你好 nodejs'); res.write('我是第一个 nodejs 程序'); res.end(); /* 结束响应 */ &#125;).listen(8001); 二、WEB 服务器介绍 Web 服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以向浏览器等Web 客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个 Web 服务器是 Apache Nginx IIS。 静态服务器：就是不支持动态页面和支持数据库的服务器空间，这样的服务器一般就只能放文件或者静态的页面，一般也就是html结尾或者htm结尾的页面。 1234567891011121314151617181920212223242526272829303132333435363738var http = require('http');var fs = require('fs');var path = require('path');var url = require('url');var mimeModel = require('./model/getmime.js');console.log(mimeModel.getMime('.html'));http.createServer(function(req,res)&#123; // req.url能拿到浏览器的输入地址 // var pathname = req.url; var pathname = url.parse(req.url).pathname; var extname = path.extname(pathname); var mime = mimeModel.getMime(extname); // 获取文件类型 if(pathname=='/')&#123; pathname = 'json/index.html'; // 默认加载的首页 &#125; if(pathname!='/favicon.ico')&#123; //过滤favicon.ico请求 console.log(pathname); fs.readFile('static/'+pathname,function(err,data)&#123; if(err)&#123; console.log('404'); fs.readFile('static/json/404.html',function(err,data404)&#123; if(err)&#123; console.log(err); &#125;else&#123; // res.writeHead(200,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); res.writeHead(200,&#123;"Content-Type":""+mime+";charset='utf-8'"&#125;); res.write(data404); res.end(); &#125; &#125;) &#125;else&#123; res.writeHead(200,&#123;"Content-Type":""+mime+";charset='utf-8'"&#125;); res.write(data); res.end(); &#125; &#125;) &#125;&#125;).listen(8888); 00services1.js 1234567891011121314151617181920212223242526//引入http模块var http=require('http');//fs模块var fs=require('fs');http.createServer(function(req,res)&#123; //http://localhost:8001/news.html /news.html //http://localhost:8001/index.html /index.html //css/dmb.bottom.css var pathname=req.url; if(pathname=='/')&#123; pathname='/index.html'; /*默认加载的首页*/ &#125; if(pathname!='/favicon.ico')&#123; /*过滤请求favicon.ico*/ console.log(pathname); //文件操作获取 static下面的index.html fs.readFile('static/'+pathname,function(err,data)&#123; if(err)&#123; /*么有这个文件*/ console.log('404'); &#125;else&#123; /*返回这个文件*/ res.writeHead(200,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); res.write(data); res.end(); /*结束响应*/ &#125; &#125;) &#125;&#125;).listen(8001); 00services2.js 1234567891011121314151617181920212223242526272829303132333435363738394041//引入http模块var http=require('http');//fs模块var fs=require('fs');//path模块var path=require('path'); /*nodejs自带的模块*/var mimeModel=require('./model/getmime.js');//console.log(mime.getMime('.css')); //获取文件类型http.createServer(function(req,res)&#123; //http://localhost:8001/news.html /news.html //http://localhost:8001/index.html /index.html //css/dmb.bottom.css var pathname=req.url; if(pathname=='/')&#123; pathname='/index.html'; /*默认加载的首页*/ &#125; //获取文件的后缀名 var extname=path.extname(pathname); if(pathname!='/favicon.ico')&#123; /*过滤请求favicon.ico*/ //console.log(pathname); //文件操作获取 static下面的index.html fs.readFile('static/'+pathname,function(err,data)&#123; if(err)&#123; /*么有这个文件*/ console.log('404'); fs.readFile('static/404.html',function(error,data404)&#123; if(error)&#123; console.log(error); &#125; res.writeHead(404,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); res.write(data404); res.end(); /*结束响应*/ &#125;) &#125;else&#123; /*返回这个文件*/ var mime=mimeModel.getMime(extname); /*获取文件类型*/ res.writeHead(200,&#123;"Content-Type":""+mime+";charset='utf-8'"&#125;); res.write(data); res.end(); /*结束响应*/ &#125; &#125;) &#125;&#125;).listen(8001); 00services3.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445//引入http模块var http=require('http');//fs模块var fs=require('fs');//path模块var path=require('path'); /*nodejs自带的模块*///url模块var url=require('url');var mimeModel=require('./model/getmime.js');//console.log(mime.getMime('.css')); //获取文件类型http.createServer(function(req,res)&#123; //http://localhost:8001/news.html /news.html //http://localhost:8001/index.html /index.html //css/dmb.bottom.css //xxx.json?214214124 var pathname=url.parse(req.url).pathname; console.log(pathname); if(pathname=='/')&#123; pathname='/index.html'; /*默认加载的首页*/ &#125; //获取文件的后缀名 var extname=path.extname(pathname); if(pathname!='/favicon.ico')&#123; /*过滤请求favicon.ico*/ //console.log(pathname); //文件操作获取 static下面的index.html fs.readFile('static/'+pathname,function(err,data)&#123; if(err)&#123; /*么有这个文件*/ console.log('404'); fs.readFile('static/404.html',function(error,data404)&#123; if(error)&#123; console.log(error); &#125; res.writeHead(404,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); res.write(data404); res.end(); /*结束响应*/ &#125;) &#125;else&#123; /*返回这个文件*/ var mime=mimeModel.getMime(extname); /*获取文件类型*/ res.writeHead(200,&#123;"Content-Type":""+mime+";charset='utf-8'"&#125;); res.write(data); res.end(); /*结束响应*/ &#125; &#125;) &#125;&#125;).listen(8001); 00services4.js 1234567891011//引入http模块var http=require('http');//fs模块var fs=require('fs');//path模块var path=require('path'); /*nodejs自带的模块*///url模块var url=require('url');var mimeModel=require('./model/getmimefromfile.js');//console.log(); //获取文件类型console.log(mimeModel.getMime(fs, '.css')); 00services5.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//引入http模块var http=require('http');//fs模块var fs=require('fs');//path模块var path=require('path'); /*nodejs自带的模块*///url模块var url=require('url');//引入扩展名的方法是在文件里面获取到的。var mimeModel=require('./model/getmimefromfile.js');//console.log(mimeModel.getMime('.css')); //获取文件类型http.createServer(function(req,res)&#123; //http://localhost:8001/news.html /news.html //http://localhost:8001/index.html /index.html //css/dmb.bottom.css //xxx.json?214214124 var pathname=url.parse(req.url).pathname; console.log(pathname); if(pathname=='/')&#123; pathname='/index.html'; /*默认加载的首页*/ &#125; //获取文件的后缀名 var extname=path.extname(pathname); if(pathname!='/favicon.ico')&#123; /*过滤请求favicon.ico*/ //console.log(pathname); //文件操作获取 static下面的index.html fs.readFile('static/'+pathname,function(err,data)&#123; if(err)&#123; /*么有这个文件*/ console.log('404'); fs.readFile('static/404.html',function(error,data404)&#123; if(error)&#123; console.log(error); &#125; res.writeHead(404,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); res.write(data404); res.end(); /*结束响应*/ &#125;) &#125;else&#123; /*返回这个文件*/ var mime=mimeModel.getMime(fs,extname); /*获取文件类型*/ res.writeHead(200,&#123;"Content-Type":""+mime+";charset='utf-8'"&#125;); res.write(data); res.end(); /*结束响应*/ &#125; &#125;) &#125;&#125;).listen(8002); 00services6.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//引入http模块var http=require('http');//fs模块var fs=require('fs');//path模块var path=require('path'); /*nodejs自带的模块*///url模块var url=require('url');var events=require('events');var EventEmitter=new events.EventEmitter();var mimeModel=require('./model/getmimefromfile_events.js');//引入扩展名的方法是在文件里面获取到的。//console.log(mimeModel.getMime('.css')); //获取文件类型http.createServer(function(req,res)&#123; //http://localhost:8001/news.html /news.html //http://localhost:8001/index.html /index.html //css/dmb.bottom.css //xxx.json?214214124 var pathname=url.parse(req.url).pathname; console.log(pathname); if(pathname=='/')&#123; pathname='/index.html'; /*默认加载的首页*/ &#125; //获取文件的后缀名 var extname=path.extname(pathname); if(pathname!='/favicon.ico')&#123; /*过滤请求favicon.ico*/ //console.log(pathname); //文件操作获取 static下面的index.html fs.readFile('static/'+pathname,function(err,data)&#123; if(err)&#123; /*么有这个文件*/ console.log('404'); fs.readFile('static/404.html',function(error,data404)&#123; if(error)&#123; console.log(error); &#125; res.writeHead(404,&#123;"Content-Type":"text/html;charset='utf-8'"&#125;); res.write(data404); res.end(); /*结束响应*/ &#125;) &#125;else&#123; /*返回这个文件*/ mimeModel.getMime(fs,EventEmitter,extname); /*调用获取数据的方法*/ EventEmitter.on('to_mime',function(mime)&#123; res.writeHead(200,&#123;"Content-Type":""+mime+";charset='utf-8'"&#125;); //res.write(data); res.end(data); /*结束响应*/ &#125;) &#125; &#125;) &#125;&#125;).listen(8002); mime.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484&#123; ".323":"text/h323" , ".3gp":"video/3gpp" , ".aab":"application/x-authoware-bin" , ".aam":"application/x-authoware-map" , ".aas":"application/x-authoware-seg" , ".acx":"application/internet-property-stream" , ".ai":"application/postscript" , ".aif":"audio/x-aiff" , ".aifc":"audio/x-aiff" , ".aiff":"audio/x-aiff" , ".als":"audio/X-Alpha5" , ".amc":"application/x-mpeg" , ".ani":"application/octet-stream" , ".apk":"application/vnd.android.package-archive" , ".asc":"text/plain" , ".asd":"application/astound" , ".asf":"video/x-ms-asf" , ".asn":"application/astound" , ".asp":"application/x-asap" , ".asr":"video/x-ms-asf" , ".asx":"video/x-ms-asf" , ".au":"audio/basic" , ".avb":"application/octet-stream" , ".avi":"video/x-msvideo" , ".awb":"audio/amr-wb" , ".axs":"application/olescript" , ".bas":"text/plain" , ".bcpio":"application/x-bcpio" , ".bin ":"application/octet-stream" , ".bld":"application/bld" , ".bld2":"application/bld2" , ".bmp":"image/bmp" , ".bpk":"application/octet-stream" , ".bz2":"application/x-bzip2" , ".c":"text/plain" , ".cal":"image/x-cals" , ".cat":"application/vnd.ms-pkiseccat" , ".ccn":"application/x-cnc" , ".cco":"application/x-cocoa" , ".cdf":"application/x-cdf" , ".cer":"application/x-x509-ca-cert" , ".cgi":"magnus-internal/cgi" , ".chat":"application/x-chat" , ".class":"application/octet-stream" , ".clp":"application/x-msclip" , ".cmx":"image/x-cmx" , ".co":"application/x-cult3d-object" , ".cod":"image/cis-cod" , ".conf":"text/plain" , ".cpio":"application/x-cpio" , ".cpp":"text/plain" , ".cpt":"application/mac-compactpro" , ".crd":"application/x-mscardfile" , ".crl":"application/pkix-crl" , ".crt":"application/x-x509-ca-cert" , ".csh":"application/x-csh" , ".csm":"chemical/x-csml" , ".csml":"chemical/x-csml" , ".css":"text/css" , ".cur":"application/octet-stream" , ".dcm":"x-lml/x-evm" , ".dcr":"application/x-director" , ".dcx":"image/x-dcx" , ".der":"application/x-x509-ca-cert" , ".dhtml":"text/html" , ".dir":"application/x-director" , ".dll":"application/x-msdownload" , ".dmg":"application/octet-stream" , ".dms":"application/octet-stream" , ".doc":"application/msword" , ".docx":"application/vnd.openxmlformats-officedocument.wordprocessingml.document" , ".dot":"application/msword" , ".dvi":"application/x-dvi" , ".dwf":"drawing/x-dwf" , ".dwg":"application/x-autocad" , ".dxf":"application/x-autocad" , ".dxr":"application/x-director" , ".ebk":"application/x-expandedbook" , ".emb":"chemical/x-embl-dl-nucleotide" , ".embl":"chemical/x-embl-dl-nucleotide" , ".eps":"application/postscript" , ".epub":"application/epub+zip" , ".eri":"image/x-eri" , ".es":"audio/echospeech" , ".esl":"audio/echospeech" , ".etc":"application/x-earthtime" , ".etx":"text/x-setext" , ".evm":"x-lml/x-evm" , ".evy":"application/envoy" , ".exe":"application/octet-stream" , ".fh4":"image/x-freehand" , ".fh5":"image/x-freehand" , ".fhc":"image/x-freehand" , ".fif":"application/fractals" , ".flr":"x-world/x-vrml" , ".flv":"flv-application/octet-stream" , ".fm":"application/x-maker" , ".fpx":"image/x-fpx" , ".fvi":"video/isivideo" , ".gau":"chemical/x-gaussian-input" , ".gca":"application/x-gca-compressed" , ".gdb":"x-lml/x-gdb" , ".gif":"image/gif" , ".gps":"application/x-gps" , ".gtar":"application/x-gtar" , ".gz":"application/x-gzip" , ".h":"text/plain" , ".hdf":"application/x-hdf" , ".hdm":"text/x-hdml" , ".hdml":"text/x-hdml" , ".hlp":"application/winhlp" , ".hqx":"application/mac-binhex40" , ".hta":"application/hta" , ".htc":"text/x-component" , ".htm":"text/html" , ".html":"text/html" , ".hts":"text/html" , ".htt":"text/webviewhtml" , ".ice":"x-conference/x-cooltalk" , ".ico":"image/x-icon" , ".ief":"image/ief" , ".ifm":"image/gif" , ".ifs":"image/ifs" , ".iii":"application/x-iphone" , ".imy":"audio/melody" , ".ins":"application/x-internet-signup" , ".ips":"application/x-ipscript" , ".ipx":"application/x-ipix" , ".isp":"application/x-internet-signup" , ".it":"audio/x-mod" , ".itz":"audio/x-mod" , ".ivr":"i-world/i-vrml" , ".j2k":"image/j2k" , ".jad":"text/vnd.sun.j2me.app-descriptor" , ".jam":"application/x-jam" , ".jar":"application/java-archive" , ".java":"text/plain" , ".jfif":"image/pipeg" , ".jnlp":"application/x-java-jnlp-file" , ".jpe":"image/jpeg" , ".jpeg":"image/jpeg" , ".jpg":"image/jpeg" , ".jpz":"image/jpeg" , ".js":"application/x-javascript" , ".jwc":"application/jwc" , ".kjx":"application/x-kjx" , ".lak":"x-lml/x-lak" , ".latex":"application/x-latex" , ".lcc":"application/fastman" , ".lcl":"application/x-digitalloca" , ".lcr":"application/x-digitalloca" , ".lgh":"application/lgh" , ".lha":"application/octet-stream" , ".lml":"x-lml/x-lml" , ".lmlpack":"x-lml/x-lmlpack" , ".log":"text/plain" , ".lsf":"video/x-la-asf" , ".lsx":"video/x-la-asf" , ".lzh":"application/octet-stream" , ".m13":"application/x-msmediaview" , ".m14":"application/x-msmediaview" , ".m15":"audio/x-mod" , ".m3u":"audio/x-mpegurl" , ".m3url":"audio/x-mpegurl" , ".m4a":"audio/mp4a-latm" , ".m4b":"audio/mp4a-latm" , ".m4p":"audio/mp4a-latm" , ".m4u":"video/vnd.mpegurl" , ".m4v":"video/x-m4v" , ".ma1":"audio/ma1" , ".ma2":"audio/ma2" , ".ma3":"audio/ma3" , ".ma5":"audio/ma5" , ".man":"application/x-troff-man" , ".map":"magnus-internal/imagemap" , ".mbd":"application/mbedlet" , ".mct":"application/x-mascot" , ".mdb":"application/x-msaccess" , ".mdz":"audio/x-mod" , ".me":"application/x-troff-me" , ".mel":"text/x-vmel" , ".mht":"message/rfc822" , ".mhtml":"message/rfc822" , ".mi":"application/x-mif" , ".mid":"audio/mid" , ".midi":"audio/midi" , ".mif":"application/x-mif" , ".mil":"image/x-cals" , ".mio":"audio/x-mio" , ".mmf":"application/x-skt-lbs" , ".mng":"video/x-mng" , ".mny":"application/x-msmoney" , ".moc":"application/x-mocha" , ".mocha":"application/x-mocha" , ".mod":"audio/x-mod" , ".mof":"application/x-yumekara" , ".mol":"chemical/x-mdl-molfile" , ".mop":"chemical/x-mopac-input" , ".mov":"video/quicktime" , ".movie":"video/x-sgi-movie" , ".mp2":"video/mpeg" , ".mp3":"audio/mpeg" , ".mp4":"video/mp4" , ".mpa":"video/mpeg" , ".mpc":"application/vnd.mpohun.certificate" , ".mpe":"video/mpeg" , ".mpeg":"video/mpeg" , ".mpg":"video/mpeg" , ".mpg4":"video/mp4" , ".mpga":"audio/mpeg" , ".mpn":"application/vnd.mophun.application" , ".mpp":"application/vnd.ms-project" , ".mps":"application/x-mapserver" , ".mpv2":"video/mpeg" , ".mrl":"text/x-mrml" , ".mrm":"application/x-mrm" , ".ms":"application/x-troff-ms" , ".msg":"application/vnd.ms-outlook" , ".mts":"application/metastream" , ".mtx":"application/metastream" , ".mtz":"application/metastream" , ".mvb":"application/x-msmediaview" , ".mzv":"application/metastream" , ".nar":"application/zip" , ".nbmp":"image/nbmp" , ".nc":"application/x-netcdf" , ".ndb":"x-lml/x-ndb" , ".ndwn":"application/ndwn" , ".nif":"application/x-nif" , ".nmz":"application/x-scream" , ".nokia-op-logo":"image/vnd.nok-oplogo-color" , ".npx":"application/x-netfpx" , ".nsnd":"audio/nsnd" , ".nva":"application/x-neva1" , ".nws":"message/rfc822" , ".oda":"application/oda" , ".ogg":"audio/ogg" , ".oom":"application/x-AtlasMate-Plugin" , ".p10":"application/pkcs10" , ".p12":"application/x-pkcs12" , ".p7b":"application/x-pkcs7-certificates" , ".p7c":"application/x-pkcs7-mime" , ".p7m":"application/x-pkcs7-mime" , ".p7r":"application/x-pkcs7-certreqresp" , ".p7s":"application/x-pkcs7-signature" , ".pac":"audio/x-pac" , ".pae":"audio/x-epac" , ".pan":"application/x-pan" , ".pbm":"image/x-portable-bitmap" , ".pcx":"image/x-pcx" , ".pda":"image/x-pda" , ".pdb":"chemical/x-pdb" , ".pdf":"application/pdf" , ".pfr":"application/font-tdpfr" , ".pfx":"application/x-pkcs12" , ".pgm":"image/x-portable-graymap" , ".pict":"image/x-pict" , ".pko":"application/ynd.ms-pkipko" , ".pm":"application/x-perl" , ".pma":"application/x-perfmon" , ".pmc":"application/x-perfmon" , ".pmd":"application/x-pmd" , ".pml":"application/x-perfmon" , ".pmr":"application/x-perfmon" , ".pmw":"application/x-perfmon" , ".png":"image/png" , ".pnm":"image/x-portable-anymap" , ".pnz":"image/png" , ".pot,":"application/vnd.ms-powerpoint" , ".ppm":"image/x-portable-pixmap" , ".pps":"application/vnd.ms-powerpoint" , ".ppt":"application/vnd.ms-powerpoint" , ".pptx":"application/vnd.openxmlformats-officedocument.presentationml.presentation" , ".pqf":"application/x-cprplayer" , ".pqi":"application/cprplayer" , ".prc":"application/x-prc" , ".prf":"application/pics-rules" , ".prop":"text/plain" , ".proxy":"application/x-ns-proxy-autoconfig" , ".ps":"application/postscript" , ".ptlk":"application/listenup" , ".pub":"application/x-mspublisher" , ".pvx":"video/x-pv-pvx" , ".qcp":"audio/vnd.qcelp" , ".qt":"video/quicktime" , ".qti":"image/x-quicktime" , ".qtif":"image/x-quicktime" , ".r3t":"text/vnd.rn-realtext3d" , ".ra":"audio/x-pn-realaudio" , ".ram":"audio/x-pn-realaudio" , ".rar":"application/octet-stream" , ".ras":"image/x-cmu-raster" , ".rc":"text/plain" , ".rdf":"application/rdf+xml" , ".rf":"image/vnd.rn-realflash" , ".rgb":"image/x-rgb" , ".rlf":"application/x-richlink" , ".rm":"audio/x-pn-realaudio" , ".rmf":"audio/x-rmf" , ".rmi":"audio/mid" , ".rmm":"audio/x-pn-realaudio" , ".rmvb":"audio/x-pn-realaudio" , ".rnx":"application/vnd.rn-realplayer" , ".roff":"application/x-troff" , ".rp":"image/vnd.rn-realpix" , ".rpm":"audio/x-pn-realaudio-plugin" , ".rt":"text/vnd.rn-realtext" , ".rte":"x-lml/x-gps" , ".rtf":"application/rtf" , ".rtg":"application/metastream" , ".rtx":"text/richtext" , ".rv":"video/vnd.rn-realvideo" , ".rwc":"application/x-rogerwilco" , ".s3m":"audio/x-mod" , ".s3z":"audio/x-mod" , ".sca":"application/x-supercard" , ".scd":"application/x-msschedule" , ".sct":"text/scriptlet" , ".sdf":"application/e-score" , ".sea":"application/x-stuffit" , ".setpay":"application/set-payment-initiation" , ".setreg":"application/set-registration-initiation" , ".sgm":"text/x-sgml" , ".sgml":"text/x-sgml" , ".sh":"application/x-sh" , ".shar":"application/x-shar" , ".shtml":"magnus-internal/parsed-html" , ".shw":"application/presentations" , ".si6":"image/si6" , ".si7":"image/vnd.stiwap.sis" , ".si9":"image/vnd.lgtwap.sis" , ".sis":"application/vnd.symbian.install" , ".sit":"application/x-stuffit" , ".skd":"application/x-Koan" , ".skm":"application/x-Koan" , ".skp":"application/x-Koan" , ".skt":"application/x-Koan" , ".slc":"application/x-salsa" , ".smd":"audio/x-smd" , ".smi":"application/smil" , ".smil":"application/smil" , ".smp":"application/studiom" , ".smz":"audio/x-smd" , ".snd":"audio/basic" , ".spc":"application/x-pkcs7-certificates" , ".spl":"application/futuresplash" , ".spr":"application/x-sprite" , ".sprite":"application/x-sprite" , ".sdp":"application/sdp" , ".spt":"application/x-spt" , ".src":"application/x-wais-source" , ".sst":"application/vnd.ms-pkicertstore" , ".stk":"application/hyperstudio" , ".stl":"application/vnd.ms-pkistl" , ".stm":"text/html" , ".svg":"image/svg+xml" , ".sv4cpio":"application/x-sv4cpio" , ".sv4crc":"application/x-sv4crc" , ".svf":"image/vnd" , ".svg":"image/svg+xml" , ".svh":"image/svh" , ".svr":"x-world/x-svr" , ".swf":"application/x-shockwave-flash" , ".swfl":"application/x-shockwave-flash" , ".t":"application/x-troff" , ".tad":"application/octet-stream" , ".talk":"text/x-speech" , ".tar":"application/x-tar" , ".taz":"application/x-tar" , ".tbp":"application/x-timbuktu" , ".tbt":"application/x-timbuktu" , ".tcl":"application/x-tcl" , ".tex":"application/x-tex" , ".texi":"application/x-texinfo" , ".texinfo":"application/x-texinfo" , ".tgz":"application/x-compressed" , ".thm":"application/vnd.eri.thm" , ".tif":"image/tiff" , ".tiff":"image/tiff" , ".tki":"application/x-tkined" , ".tkined":"application/x-tkined" , ".toc":"application/toc" , ".toy":"image/toy" , ".tr":"application/x-troff" , ".trk":"x-lml/x-gps" , ".trm":"application/x-msterminal" , ".tsi":"audio/tsplayer" , ".tsp":"application/dsptype" , ".tsv":"text/tab-separated-values" , ".ttf":"application/octet-stream" , ".ttz":"application/t-time" , ".txt":"text/plain" , ".uls":"text/iuls" , ".ult":"audio/x-mod" , ".ustar":"application/x-ustar" , ".uu":"application/x-uuencode" , ".uue":"application/x-uuencode" , ".vcd":"application/x-cdlink" , ".vcf":"text/x-vcard" , ".vdo":"video/vdo" , ".vib":"audio/vib" , ".viv":"video/vivo" , ".vivo":"video/vivo" , ".vmd":"application/vocaltec-media-desc" , ".vmf":"application/vocaltec-media-file" , ".vmi":"application/x-dreamcast-vms-info" , ".vms":"application/x-dreamcast-vms" , ".vox":"audio/voxware" , ".vqe":"audio/x-twinvq-plugin" , ".vqf":"audio/x-twinvq" , ".vql":"audio/x-twinvq" , ".vre":"x-world/x-vream" , ".vrml":"x-world/x-vrml" , ".vrt":"x-world/x-vrt" , ".vrw":"x-world/x-vream" , ".vts":"workbook/formulaone" , ".wav":"audio/x-wav" , ".wax":"audio/x-ms-wax" , ".wbmp":"image/vnd.wap.wbmp" , ".wcm":"application/vnd.ms-works" , ".wdb":"application/vnd.ms-works" , ".web":"application/vnd.xara" , ".wi":"image/wavelet" , ".wis":"application/x-InstallShield" , ".wks":"application/vnd.ms-works" , ".wm":"video/x-ms-wm" , ".wma":"audio/x-ms-wma" , ".wmd":"application/x-ms-wmd" , ".wmf":"application/x-msmetafile" , ".wml":"text/vnd.wap.wml" , ".wmlc":"application/vnd.wap.wmlc" , ".wmls":"text/vnd.wap.wmlscript" , ".wmlsc":"application/vnd.wap.wmlscriptc" , ".wmlscript":"text/vnd.wap.wmlscript" , ".wmv":"audio/x-ms-wmv" , ".wmx":"video/x-ms-wmx" , ".wmz":"application/x-ms-wmz" , ".wpng":"image/x-up-wpng" , ".wps":"application/vnd.ms-works" , ".wpt":"x-lml/x-gps" , ".wri":"application/x-mswrite" , ".wrl":"x-world/x-vrml" , ".wrz":"x-world/x-vrml" , ".ws":"text/vnd.wap.wmlscript" , ".wsc":"application/vnd.wap.wmlscriptc" , ".wv":"video/wavelet" , ".wvx":"video/x-ms-wvx" , ".wxl":"application/x-wxl" , ".x-gzip":"application/x-gzip" , ".xaf":"x-world/x-vrml" , ".xar":"application/vnd.xara" , ".xbm":"image/x-xbitmap" , ".xdm":"application/x-xdma" , ".xdma":"application/x-xdma" , ".xdw":"application/vnd.fujixerox.docuworks" , ".xht":"application/xhtml+xml" , ".xhtm":"application/xhtml+xml" , ".xhtml":"application/xhtml+xml" , ".xla":"application/vnd.ms-excel" , ".xlc":"application/vnd.ms-excel" , ".xll":"application/x-excel" , ".xlm":"application/vnd.ms-excel" , ".xls":"application/vnd.ms-excel" , ".xlsx":"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" , ".xlt":"application/vnd.ms-excel" , ".xlw":"application/vnd.ms-excel" , ".xm":"audio/x-mod" , ".xml":"text/plain", ".xml":"application/xml", ".xmz":"audio/x-mod" , ".xof":"x-world/x-vrml" , ".xpi":"application/x-xpinstall" , ".xpm":"image/x-xpixmap" , ".xsit":"text/xml" , ".xsl":"text/xml" , ".xul":"text/xul" , ".xwd":"image/x-xwindowdump" , ".xyz":"chemical/x-pdb" , ".yz1":"application/x-yz1" , ".z":"application/x-compress" , ".zac":"application/x-zaurus-zac" , ".zip":"application/zip" , ".json":"application/json"&#125; model/getmime.js 123456789101112exports.getMime=function(extname)&#123; /*获取后缀名的方法*/ switch (extname)&#123; case '.html': return 'text/html'; case '.css': return 'text/css'; case '.js': return 'text/javascript'; default: return 'text/html'; &#125;&#125; model/getmimefromfile_bac.js 1234567891011121314151617exports.getMime=function(fs,extname)&#123; /*获取后缀名的方法*/ //.html console.log('1'); fs.readFile('./mime.json',function(err,data)&#123; if(err)&#123; console.log('mime.json文件不存在'); return false; &#125; //console.log(data.toString()); var Mimes=JSON.parse(data.toString()); //console.log(Mimes[extname]); console.log('2'); return Mimes[extname] || 'text/html'; &#125;) console.log('3');&#125;// 1 3 undefined model/getmimefromfile.js 1234567exports.getMime=function(fs,extname)&#123; /*获取后缀名的方法*/ //把读取数据改成同步 var data=fs.readFileSync('./mime.json'); //Sync解决异步问题 //console.log(data.toString()); 转换成json字符串 var Mimes=JSON.parse(data.toString()); /*把json字符串转换成json对象*/ return Mimes[extname] || 'text/html';&#125;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08_Arrow_Function]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-08-Arrow-Function%2F</url>
    <content type="text"><![CDATA[08-Arrow Function 箭头函数 1、 Arrow Function 123function sayHi() &#123; console.log('Hello world')&#125; 1234const sayHi = user =&gt; &#123; console.log('Hello world ' + user)&#125;sayHi('danny'); 2、 fix ‘this’ problem (function在对象里叫method) 12345678var person = &#123; name: 'Danny', gender: 'male', testing: function() &#123; console.log(this) &#125;&#125;person.testing() 1&#123; name: 'Danny', gender: 'male', testing: [Function: testing] &#125; ES6: this returns to person object 12345678910var person = &#123; name: 'Danny', gender: 'male', testing: function() &#123; (() =&gt; &#123; console.log(this) &#125;)() &#125;&#125;person.testing() 3、arrow function不能来做constructor 12345678910111213141516171819function Person(first, last) &#123; this.firstName = first; this.lastName = last;&#125;class Person &#123; constructor(first, last) &#123; this.firstName = first; this.lastName = last; &#125;&#125;let Person = (first, last) =&gt; &#123; // wrong this.firstName = first, this.lastName = last&#125;var danny = new Person('danny', 'huang')console.log('danny', danny)]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07_Array_Cardio]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-07-Array-Cardio%2F</url>
    <content type="text"><![CDATA[07-Array Cardio处理Array forEach map Filter Reduce 1234567891011121314151617181920212223242526272829303132const users = [ &#123; id: 1, name: 'Allison', age: 4, gender: 'female' &#125;, &#123; id: 2, name: 'Derek', age: 1, gender: 'male' &#125;, &#123; id: 3, name: 'Irene', age: 35, gender: 'female' &#125;, &#123; id: 4, name: 'Danny', age: 32, gender: 'male' &#125;, &#123; id: 5, name: 'Alin', age: 25, gender: 'female' &#125;,] 1、forEach： log each name 123users.forEach((user) =&gt; &#123; console.log(user.name)&#125;) 12345AllisonDerekIreneDannyAlin 把每个user age乘以2 1234users.forEach((user, index) =&gt; &#123; return users[index].age = user.age * 2&#125;)console.log('users', users) 12345users [ &#123; id: 1, name: 'Allison', age: 8, gender: 'female' &#125;, &#123; id: 2, name: 'Derek', age: 2, gender: 'male' &#125;, &#123; id: 3, name: 'Irene', age: 70, gender: 'female' &#125;, &#123; id: 4, name: 'Danny', age: 64, gender: 'male' &#125;, &#123; id: 5, name: 'Alin', age: 50, gender: 'female' &#125; ] 2、map log username 1users.map(user =&gt; console.log(user.name))//只有一个参数不需要(),只有一行不需要&#123;&#125; 12345AllisonDerekIreneDannyAlin 把每个user age乘以2 12345678910let doubled = users.map((user) =&gt; &#123; let tempObj = &#123;&#125; // tempObj不能直接=，要复制，因为tempObj是reference tempObj = &#123;...user&#125; tempObj.age = user.age * 2 return tempObj&#125;)console.log('doubled', doubled)console.log('users', users)// map won't change original array// foreach will change original array 12345678910doubled [ &#123; id: 1, name: 'Allison', age: 8, gender: 'female' &#125;, &#123; id: 2, name: 'Derek', age: 2, gender: 'male' &#125;, &#123; id: 3, name: 'Irene', age: 70, gender: 'female' &#125;, &#123; id: 4, name: 'Danny', age: 64, gender: 'male' &#125;, &#123; id: 5, name: 'Alin', age: 50, gender: 'female' &#125; ]users [ &#123; id: 1, name: 'Allison', age: 4, gender: 'female' &#125;, &#123; id: 2, name: 'Derek', age: 1, gender: 'male' &#125;, &#123; id: 3, name: 'Irene', age: 35, gender: 'female' &#125;, &#123; id: 4, name: 'Danny', age: 32, gender: 'male' &#125;, &#123; id: 5, name: 'Alin', age: 25, gender: 'female' &#125; ] map不会改变原来的array，但是forEach会改变原来的array。 3、Filter 只要age低于18 123456let kids = users.filter((user) =&gt; &#123; let tempObj = &#123;&#125; tempObj = &#123;...user&#125; return tempObj.age &lt; 18&#125;)console.log('kids',kids); 12kids [ &#123; id: 1, name: 'Allison', age: 4, gender: 'female' &#125;, &#123; id: 2, name: 'Derek', age: 1, gender: 'male' &#125; ] Only female 123456let female = users.filter((user) =&gt; &#123; let tempObj = &#123;&#125; tempObj = &#123;...user&#125; return tempObj.gender === 'female'&#125;)console.log('female', female) 123female [ &#123; id: 1, name: 'Allison', age: 4, gender: 'female' &#125;, &#123; id: 3, name: 'Irene', age: 35, gender: 'female' &#125;, &#123; id: 5, name: 'Alin', age: 25, gender: 'female' &#125; ] 4、Reduce 最常用就是把数组中的数字加在一起 123456789let totalAge = users.reduce((acc, obj) =&gt; &#123; return acc + obj.age&#125;, 0) //第一个值acc设为0// 0 + 4 = 4// 4 + 1 = 5// 5 + 35 = 40// 40 + 32 = 72// 72 + 25 = 97console.log(totalAge); //97]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06_Promise]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-06-Promise%2F</url>
    <content type="text"><![CDATA[06-Node.js Promise处理异步 一、同步与异步 Async = 非同步 sync = 同步 synchronous = one at a time 第一个执行完才执行下一个 Asynchronous = more one at a time 执行了就马上换下一个指令 二、Async Actions click、Ajax、Setlnterval 解决方法：callback、Promise、Async await 1、callback callbak是一个function里面的function 12345var proveIt = function()&#123; alert('you triggered'+this.id);&#125;document.getElementById('clicker').addEventListener('click',proveIt);// click之后就执行proveIt这个function 2、Promise ES6 return resolve or reject ES6 Promise的实例，会确保Promise一实例化后就固定住状态，要不就是“已实现”，要不就是“已拒绝”。 123456789const promise = new Promise(function(resplve,reject)&#123; resolve(value); // 成功时 reject(reason); // 失败时&#125;);promise.then(function(value)&#123; // 已实现时&#125;,function(reason)&#123; // 已拒绝时&#125;); Examples: SetInterval 1234567891011121314// console.log(Math.floor(Math.random()*100)+1);// console.log(Math.random());function logWord(word)&#123; setTimeout(function()&#123; console.log(word); &#125;,Math.floor(Math.random()*100)+1);&#125;function logAll()&#123; logWord('1'); logWord('2'); logWord('3');&#125;logAll();//每一次结果都不一样，因为是异步 SetInterval是异步的，所以它执行了第一个指令就会马上执行下一个，所以顺序不会固定。 (1) 解决方法：callback 1234567891011121314function logWord(word,callback)&#123; setTimeout(function()&#123; console.log(word); callback(); &#125;,Math.floor(Math.random()*100+1));&#125;function logAll()&#123; logWord('1',function()&#123; logWord('2',function()&#123; logWord('3',function()&#123;&#125;) &#125;) &#125;)&#125;logAll(); Callbak Hell：callback要debug建议用console.log callback一直callback下去，如果中间哪个环节错了，很难让人debug。 (2) 解决方法：Promise 1234567891011121314151617function logWord(word)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(word); resolve(); &#125;,Math.floor(Math.random()*100+1)); &#125;);&#125;function logAll()&#123; logWord('1') .then(function()&#123; return logWord('2'); &#125;).then(function()&#123; return logWord('3'); &#125;)&#125;logAll(); Promise可以写得更简洁一点，ES6有一个箭头函数，所以还可以这么写： 12345function logAll()&#123; logWord('1') .then(()=&gt;logWord('2')) .then(()=&gt;logWord('3'))&#125;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05_Fs_Module]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-05-Fs-Module%2F</url>
    <content type="text"><![CDATA[05-Node.js fs模块 fs.stat 检测是文件还是目录 fs.mkdir 创建目录 fs.writeFile 创建写入文件 fs.appendFile 追加文件 fs.readFile 读取文件 fs.readdir 读取目录 fs.rename 重命名 fs.rmdir 删除目录 fs.unlink 删除文件 fs.createReadStream 从文件流中读取数据 fs.createWriteStream 写入文件 管道流 1、fs.stat 检测是文件还是目录 12345678910const fs = require('fs') fs .stat('hello.js',(error,stats) =&gt;&#123; if(error)&#123; console.log(error) &#125;else&#123; console.log(stats) console.log(`文件：$&#123;stats.isFile()&#125;`) console.log(`目录：$&#123;stats.isDirectory()&#125;`) &#125; &#125;) 12345678910111213141516171819202122&gt; node testStats &#123; dev: 315831262, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 2533274790764158, size: 17, blocks: undefined, atimeMs: 1553754246606.595, mtimeMs: 1553754257410.068, ctimeMs: 1553754257410.068, birthtimeMs: 1553754246606.595, atime: 2019-03-28T06:24:06.607Z, mtime: 2019-03-28T06:24:17.410Z, ctime: 2019-03-28T06:24:17.410Z, birthtime: 2019-03-28T06:24:06.607Z &#125;文件：true目录：false 2、fs.mkdir 创建目录 123456789const fs = require ('fs') fs.mkdir('logs', (error) =&gt; &#123; if(error)&#123; console.log(error) &#125;else&#123; console.log('成功创建目录：logs') &#125;&#125;) // 创建logs目录（在同一目录下） 3、fs.writeFile 创建写入文件 如果不存在就创建，已经存在会覆盖 123456789const fs = require ('fs') fs.writeFile('logs/hello.log','您好~\n',(error)=&gt;&#123; if(error)&#123; console .log(error) &#125;else&#123; console .log('成功写入文件') &#125; &#125;) // 在logs目录下创建了hello.log文件，内容为'您好~' 4、fs.appendFile 追加文件 如果文件不存在就创建，如果存在就追加内容 123456789const fs = require ('fs') fs.appendFile('logs/hello.log','hello~\n',(error)=&gt;&#123; if(error)&#123; console .log(error) &#125;else&#123; console .log('成功写入文件') &#125; &#125;) // 在logs目下的hello.log文件中追加内容'hello~' 5、fs.readFile 读取文件 12345678const fs = require ('fs') fs.readFile('logs/hello.log','utf8',(error,data)=&gt;&#123; if(error)&#123; console .log(error) &#125;else&#123; console .log(data) &#125;&#125;) 123&gt;node test您好~hello~ 6、fs.readdir 读取目录 拿到一个文件夹下面的所有目录和文件 12345678const fs = require('fs') fs.readdir('logs',(error,files)=&gt;&#123; if(error)&#123; console.log(error) &#125;else&#123; console.log(files) &#125;&#125;) 12&gt; node test[ 'hello.log' ] 7、fs.rename 重命名 123456789const fs = reuiure('fs');fs.rename('logs/hello.log','logs/haha.log',function(err)&#123; if(err)&#123; console.log(err); return false; &#125; console.log('重命名成功');&#125;)// logs目录下的hello.log文件重命名为haha.log 可以用作剪切功能 123456789const fs = require('fs');fs.rename('html/css/basic.css','html/style.css',function(err)&#123; if(err)&#123; console.log(err); return false; &#125; console.log('剪切成功');&#125;)// html/css目录下的basic.css被剪切到style.css中（basic.css不见了，style.css存在，但内容变为原来basic.css中的内容） 8、fs.rmdir 删除目录 12345678910const fs = require('fs');const fs = require('fs');fs.rmdir('logs',(error)=&gt;&#123; if(error) &#123; console.log(error) &#125;else&#123; console.log('成功的删除了目录：logs') &#125; &#125;)// 只有当logs目录下为空（没有任何文件和目录时才可被删除) 9、fs.unlink 删除文件 123456789const fs = require('fs');var file = 'haha.log';fs.unlink(`logs/$&#123;file&#125;`,(error)=&gt;&#123; if(error)&#123; console.log(error) &#125;else&#123; console.log(`成功的删除了文件: $&#123;file&#125;`) &#125; &#125;) 12&gt;node test成功的删除了文件: haha.log 10、fs.createReadStream 以文件流的方式读取数据 12345678910111213141516171819const fs = require ('fs') var fileReadStream = fs.createReadStream('data.json') let count =0; var data =''; // 处理事件流：data、end、errorfileReadStream.on('data',(chunk)=&gt;&#123; console.log(`$&#123; ++ count &#125; 接收到：$&#123;chunk.length&#125;`); data +=chunk &#125;) fileReadStream .on('end',()=&gt;&#123; console.log('--- 结束 ---'); console.log( count ); console.log( data );&#125;) fileReadStream.on('error',(error)=&gt;&#123; console.log(error) &#125;) 12345678910111213141516const fs = require('fs');var readStream = fs.createReadStream('input.txt');var data = ''; // 保存数据var count = 0;// 处理事件流：data、end、errorreadStream.on('data',function(chunk)&#123; data+=chunk; count++;&#125;);readStream.on('end',function(chunk)&#123; console.log(count); // 用文件流的方式读取，文件比较小的时候读取一次就读完了；文件比较大的时候，要读取多次 console.log(data);&#125;)readStream.on('error',function(err)&#123; console.log(err);&#125;) 11、fs.createWriteStream 以文件流的方式写入文件 1234567891011121314const fs = require('fs');var data = '我是从数据库获取的数据，我要保存进文件里\n';// 创建一个可写入的流，写入到文件output.txtvar writeStream = fs.createWriteStream('output.txt');for(let i=0;i&lt;100;i++)&#123; writeStream.write(data,'utf8'); // 写入数据&#125;writeStream.end(); // 标记写入完成writeStream.on('finish',function()&#123; // finish与end配对才有用 console.log('写入完成');&#125;)writeStream.on('error',function()&#123; console.log('写入失败');&#125;) 12、readStream.pipe(writeStream) 以管道流的方式读取文件和写入文件 管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传 递到另外一个流中。 我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个 桶(source)流入另一个桶(dest)，这样就慢慢的实现了大文件的复制过程。 以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。 12345678const fs = require('fs');// 创建一个可读流var readStream = fs.createReadStream('input.txt');// 创建一个可写流var writeStream = fs.createWriteStream('output.txt');// 管道读写操作:读取input.txt文件内容，并将内容写入到output.txt文件中readStream.pipe(writeStream);console.log('程序执行完毕'); 练习 1、判断服务器上面有没有upload目录，如果没有的话就创建这个目录(一般用于图片上传，要上传到一个目录，如果不存在就要创建)： 1234567891011121314151617const fs = require('fs');fs.stat('upload',function(err,stats)&#123; if(err)&#123; // 目录不存在 --&gt; 如果不存在就要执行创建操作 // console.log(err); // return false; fs.mkdir('upload',function(error)&#123; if(error)&#123; console.log(error); return false; &#125; console.log('创建成功'); //如果没有此目录就创建此目录 &#125;); &#125;else&#123; console.log('目录已经存在'); console.log(stats.isDirectory()); &#125;&#125;); 12345&gt; node test创建成功&gt; node test目录已经存在true 2、找出html目录下面的所有目录并打印出来： 1234567891011121314151617const fs = require('fs');fs.readdir('html',function(err,files)&#123; if(err)&#123; console.log(err); &#125;else&#123; //拿到html目录下的所有文件和目录 // console.log(files); // 判断是目录还是文件 for(let i=0;i&lt;files.length;i++)&#123; // for循环遍历所有目录文件 console.log(files[i]); // 这里打印，files[i]就是存在的 fs.stat(files[i],function(error,stats)&#123; //判断是目录还是文件 // fs.stat是异步，先打印一下files[i] console.log(files[i]); //undefined // 你没法在这里拿到files[i],这是错误的写法 &#125;) &#125; &#125;&#125;); 正确写法：匿名自执行函数 123456789101112131415161718192021var filesArr = [];fs.readdir('html',function(err,files)&#123; if(err)&#123; console.log(err); return false; &#125;else&#123; // 判断是目录还是文件夹 console.log(files); // 数组：包含目录下所有目录和文件 (function getFile(i)&#123; if(i==files.length)&#123; console.log(filesArr); // 打印出所有的目录 return false; &#125; fs.stat('html/'+files[i],function(error,stats)&#123; if(stats.isDirectory())&#123; // 如果是目录 filesArr.push(files[i]); // 就保存数据 &#125; getFile(i+1); // 递归调用 &#125;) &#125;)(0) // 立即执行函数 &#125;&#125;) 解决异步问题 nodejs 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高，nodejs的每一个api都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。 我们经常使用的File的readFile事件就是一个并发事件。 123456console.log("1");fs.readFile("mime.json",function (err,data) &#123; console.log(data); console.log('2');&#125;);console.log("3"); 代码的执行顺序是1-3-2；但是我们很多时候会需要1-2-3的方式去执行方法，这个时候我们可以通过以下三种方式去解决这个问题： 1、将readFile改成同步方法。即readFile–&gt;readFileSync 12const fsSync = fs.readFileSync('./mime.json');const mimeObj = JSON.parse(fsSync.toString()); 2、通过回调的方式解决 123456789101112console.log("1");function getMime(callback)&#123; fs.readFile("mime.json",function (err,data) &#123; // console.log(data.toString()); callback(data.toString()) ; console.log("2"); &#125;);&#125;getMime(function (result) &#123; console.log(result); console.log("3");&#125;); 3、nodejs 有多个内置的事件，我们可以通过引入events模块，并通过实例化eventEmitter类来绑定和监听事件，通过事件驱动的方式解决异步的问题，也可以说成是广播或者订阅。 广播和接收广播 ---- 订阅和通知： 1234567891011const events = require("events");const eventEmitter = new events.EventEmitter();//监听广播eventEmitter.on('to_parent',function () &#123; //接受到了广播事件 console.log("接受到了广播事件")&#125;);setTimeout(function () &#123; console.log("开始广播"); eventEmitter.emit("to_parent","发送数据");&#125;,2000); 在readFIle中这样使用： 12345678910111213console.log("1");function getMime()&#123; fs.readFile("mime.json",function (err,data) &#123; eventEmitter.emit("to_parent",data); console.log("2"); &#125;);&#125;getMime();eventEmitter.on('to_parent',function (data) &#123; //接受到了广播事件 console.log("接受到了广播事件") console.log("3");&#125;); 4、使用Promise方法—略 Promise 是一种对异步操作的封装，可以通过独立的接口添加在异步操作执行成功、失败时执行的方法。主流的规范是 Promises/A+。 Promise中有几个状态： pending: 初始状态, 非 fulfilled 或 rejected； fulfilled: 成功的操作，为表述方便，fulfilled 使用 resolved 代替； rejected: 失败的操作。 pending可以转化为fulfilled或rejected并且只能转化一次，也就是说如果pending转化到fulfilled状态，那么就不能再转化到rejected。并且fulfilled和rejected状态只能由pending转化而来，两者之间不能互相转换。 Promise的基本语法 Promise实例必须实现then这个方法 then()必须可以接收两个函数作为参数 then()返回的必须是一个Promise实例 5、async/await方法]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04_npm]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-04-npm%2F</url>
    <content type="text"><![CDATA[04-包与npm、第三方模块安装、package.json、cnpm 一、包与 NPM 1、包 Nodejs 中除了它自己提供的核心模块外，我们可以自定义模块，也可以使用第三方的模块。Nodejs 中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。 完全符合 CommonJs 规范的包目录一般包含如下这些文件。 • package.json :包描述文件。 • bin :用于存放可执行二进制文件的目录。 • lib :用于存放 JavaScript 代码的目录。 • doc :用于存放文档的目录。 在 NodeJs 中通过 NPM 命令来下载第三方的模块（包）。 123npm i silly-datetime –save var sd = require('silly-datetime'); sd.format(new Date(), 'YYYY-MM-DD HH:mm'); 2、NPM介绍 npm是世界上最大的开放源代码的生态系统。我们可以通过npm下载各种各样的包， 这些源代码（包）我们可以在 https://www.npmjs.com 找到。 npm 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题， 常见的使用场景有以下几种： 允许用户从 NPM 服务器下载别人编写的第三方包到本地使用。(silly-datetime) 允许用户从 NPM 服务器下载并安装别人编写的命令行程序(工具)到本地使用。 （supervisor） 允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。 二、NPM 命令详解。 123456npm -v // 查看npm版本npm install moduleName //安装模块 npm uninstall moudleName //卸载模块 npm list //查看当前目录下已安装的node包npm info jquery //查看jquery的版本 npm install jquery@1.8.0 //指定版本安装 三、package.json 1、创建 package.json 12npm init npm init –yes //yes表示一路默认创建，还有 -f表示force 2、package.json 文件就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。 123456789101112131415&#123; &quot;name&quot;: &quot;test&quot;, //项目名称&quot;version&quot;: &quot;1.0.0&quot;, //项目版本号&quot;description&quot;: &quot;test&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;keywords&quot;: [ &quot;test&quot; ], &quot;author&quot;: &quot;wade&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.10.1&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;jslint&quot;: &quot;^0.6.5&quot; &#125; &#125; 必须字段： 12name //项目名称version //项目版本号 可选字段 1234title //标题author //是一个人contributors //是一组人homepage // 3、安装模块并把模块写入 package.json(依赖) 123npm install babel-cli --save-dev npm install 模块 --save npm install 模块 --save-dev 12npm install -d 就是npm install --save-devnpm insatll -s 就是npm install --save Dependencies一词的中文意思是依赖和附属的意思，而dev则是develop（开发）的简写。 所以它们的区别在 package.json 文件里面体现出来的就是，使用 --save-dev 安装的插件，被写入到 devDependencies 域里面去，而使用 --save 安装的插件，则是被写入到 dependencies 区块里面去。 package.json 文件里面的 devDependencies 和 dependencies 对象有什么区别呢？devDependencies 里面的插件只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。 使用 npm i 安装package.json里的依赖时，两部分的包都会pull下来。 比如： 我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies ； 而我们使用的一些构建工具比如glup、webpack这些只是在开发中使用的包，上线以后就和他们没关系了，所以将它写入devDependencies。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03_user_defined_module]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-03-user-defined-module%2F</url>
    <content type="text"><![CDATA[03-CommonJS和Nodejs模块、自定义模块 一、什么是 CommonJs？ JavaScript 是一个强大的面向对象语言，它有很多快速高效的解释器。然而， JavaScript 标准定义的 API 是为了构建基于浏览器的应用程序。并没有制定一个用于更广泛的应用程序的标准库。CommonJS 规范的提出,主要是为了弥补当前 JavaScript 没有标准的缺陷。它的终 极目标就是：提供一个类似 Python，Ruby 和 Java 语言的标准库,而不只是停留在小脚本程序的阶段。用 CommonJS API 编写出的应用，不仅可以利用 JavaScript 开发客户端应用，而且还可以编写以下应用。 •服务器端 JavaScript 应用程序。 （nodejs） •命令行工具。 •桌面图形界面应用程序。 CommonJS 就是模块化的标准，nodejs就是 CommonJS（模块化）的实现。 二、Nodejs 中的模块化 Node 应用由模块组成，采用 CommonJS 模块规范。 1、 在 Node中，模块分为两类: 一类是 Node 提供的模块,称为核心模块；另一类是用户编写的模块，称为文件模块。 • 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。 如：HTTP 模块 、URL 模块、Fs模块都是 nodejs 内置的核心模块，可以直接引入使用。 • 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、 速度相比核心模块稍微慢一些，但是用的非常多。这些模块需要我们自己定义。接下来我们看一下 nodejs 中的自定义模块。 2、CommonJS（Nodejs）中自定义模块的规定： （1）我们可以把公共的功能抽离成为一个单独的 js 文件作为一个模块，默认情况下面这 个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或 者属性，就必须在模块里面通过exports或者module.exports暴露属性或者方法。 （2）在需要使用这些模块的文件中，通过require的方式引入这个模块。这个时候就可以 使用模块里面暴露的属性和方法。 3、 定义使用模块： tools.js 1234567891011121314// 定义一个 tools.js 的模块 // 模块定义 var tools = &#123; sayHello: function() &#123; return 'hello NodeJS'; &#125;, add: function(x, y) &#123; return x + y; &#125; &#125;; // 模块接口的暴露 // module.exports = tools ; exports.sayHello = tools.sayHello; exports.add = tools.add; 1234var http = require ('http'); // 引入自定义的 tools.js 模块 var tools= require ('./tools'); tools.sayHello(); //使用模块 两种方法：方法一 12345module.exports = tools;-----------------------var tools = require('./tools');tools.sayHello();tools.add(); ​ 方法二 123456exports.sayHello = tools.sayHello;exports.add = tools.add;---------------------------------var tools = require('./tools');tools.sayHello();tools.add(); 由此想到的构造一个模块的方法： 12345678910111213141516171819var tools = &#123; tools01:&#123; hello:function()&#123; console.log('hello'); &#125;, elaine:function()&#123; console.log('elaine'); &#125; &#125;, tools02 :&#123; hi:function()&#123; console.log('hi'); &#125;, hongkong:function()&#123; console.log('hongkong'); &#125; &#125;&#125;module.exports = tools; 123var tools = require('./01');tools.tools01.hello();tools.tools02.hi(); 三、npm init 生成 package.json 1npm init -y]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02_http_module]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-02-http-module%2F</url>
    <content type="text"><![CDATA[02-Node.js—http模块、url模块、nodemon工具 一、Node.js创建第一个应用 1、引入http模块 1var http = require("http"); 2、创建服务器 接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。 server.js 1234567891011var http = require('http'); http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK //设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8 response.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); // 发送响应数据 "Hello World" res.end("哈哈哈哈，我买了一个 iPhone" + (1+2+3) + "s"); &#125;).listen(8888); // 终端打印如下信息 console.log('Server running at http://127.0.0.1:8888/'); 3、运行程序 用命令行切换到程序对应目录。通过 node 命令运行程序。 1node server.js 浏览器运行 : 127.0.0.1:8888 我们本地写一个 js，打死都不能直接拖入浏览器运行，但是有了 node，我 们任何一个 js 文件，都可以通过 node 来运行。也就是说，node 就是一个 js 的执行环境。 二、HTTP 模块、URL 模块 1234567891011//引用模块 var http = require("http"); //创建一个服务器，回调函数表示接收到请求之后做的事情 var server = http.createServer(function(req,res)&#123; //req 参数表示请求，res 表示响应 console.log("服务器接收到了请求" + req.url); res.end(); //End方法使Web服务器停止处理脚本并返回当前结果 &#125;); //监听端口 server.listen(3000,"127.0.0.1"); 设置一个响应头： 1res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF8"&#125;); 我们现在来看一下 req 里面能够使用的东西。 最关键的就是 req.url 属性，表示用户的请求 URL 地址。所有的路由设计，都是通过 req.url 来实现的。 我们比较关心的不是拿到 URL，而是识别这个 URL。 识别 URL，用到了下面的 url 模块 ： 123url.parse() //解析URL url.format(urlObject) //是上面 url.parse()操作的逆向操作 url.resolve(from, to) //添加或者替换地址 123456789101112131415//https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hashUrl &#123; protocol: 'https:', // 协议 slashes: true, auth: 'user:pass', // 用户名密码 host: 'sub.host.com:8080', // host主机名 port: '8080', // 端口号 hostname: 'sub.host.com', // 主机名不带端口号 hash: '#hash', // 哈希值 search: '?query=string',// 查询字符串 query: 'query=string', // 请求参数 pathname: '/p/a/t/h', // 路径名 path: '/p/a/t/h?query=string', // 带查询的路径名 href: 'https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash' // 原字符串本身&#125; 1、url.parse() 例子1 1234567891011var http = require('http');http.createServer(function(req,res)&#123; console.log(req.url); res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write('Hello World.'); res.end();&#125;).listen(8888);console.log('Server running at http://127.0.0.1:8888/');//输入localhost:8888 得到: / /favicon.ico//输入localhost:8888/news 得到: /news /favicon.ico//输入localhost:8888/news?aid=123 得到: /news?aid=123 /favicon.ico 例子2 12345678910111213var http = require('http');var url = require('url');http.createServer(function(req,res)&#123;// 输入localhost:8888/news?aid=123&amp;cid=3 拿到aid和cid// req.url 获取浏览器url输入的信息// url.parse()第二个参数是true的时候，表示把get传值转换成对象 console.log(url.parse(req.url,true).query.aid); // 获取url的get传值 console.log(url.parse(req.url,true).query.cid); // 获取url的get传值 res.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); res.write('Hello World.'); res.end();&#125;).listen(8888);console.log('Server running at http://127.0.0.1:8888/'); 2、url.format(urlObject) 一般用不着 3、url.resolve() 12&gt;url.resolve(&apos;http://example.com/&apos;,&apos;/one&apos;);&apos;http://example.com/one&apos; 三、Nodejs自启动工具nodemon 1、全局安装nodemon 1npm install -g nodemon 2、使用 以前要么是 node app，要么是npm start，有了nodemon以后，启动程序直接进入根目录，nodemon就可以了。 修改文件后，会自动重启。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01_nodejs_introduction]]></title>
    <url>%2F2019%2F04%2F22%2Fnodejs-01-nodejs-introduction%2F</url>
    <content type="text"><![CDATA[01-Node.js介绍 😊Node.js 是一个 Javascript 运行环境(runtime)。它让 JavaScript 可以开发后端程序，实现几乎其他后端语言实现的所有功能，可以与 PHP、JSP、Python、Ruby 等后端语言平起平坐。 Nodejs 是基于 V8 引擎，V8 是 Google 发布的开源 JavaScript 引擎，本身就是用于 Chrome 浏览器 的 JS 解释部分，但是 Ryan Dahl 这哥们，鬼才般的，把这个 V8 搬到了服务器上，用于做服务器的软件。 短短几年的时间，Node 取得了巨大的成功。在企业界，Node 的应用也越来越广泛，2016 年 nodeJS 官方的调查报告。2016 年全球有 350 万开发者使用 nodeJS,相比去年保持了 100%的增长率。像 Yahoo、Microsoft 这样的大公司，有好多应用已经迁移到 Node 了。国内的阿里巴巴、网易、腾讯、新浪、百度等公司的很多线上产品也纷纷改用 Node 开发，并取得了很好的效果。据统计很多 A 轮、 B 轮的创业公司更喜欢使用 NodeJs 开发。 一、Node.js的优势 Node 打破了过去 JavaScript 只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低开发成本。 超强的高并发能力：Node.js 的首要目标是提供一种简单的、用于创建高性能服务器及可在该服务器中运行的各种应用程序的开发工具。 在 Java、PHP 或者.net 等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约 2MB 内存。也就是说，理论上，一个 8GB 内存的服务器可以同时连接的最大用户数为 4000 个左右。要让 Web 应用程序支持更多的用户，就需要增加服务器的数量，而 Web 应用程序的硬件成本当然就上升了。 Node.js 不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个 内部事件，通过非阻塞 I/O、事件驱动机制，让 Node.js 程序宏观上也是并行的。使用 Node.js，一个 8GB 内存的服务器，可以同时处理超过 4 万用户的连接。 实现高性能服务器 ：严格地说，Node.js 是一个用于开发各种Web 服务器的开发工具。在 Node.js 服务器中，运行的是高性能 V8 JavaScript 脚本语言，该语言是一种可以运行在服务器端的 JavaScript 脚本语言。 那么，什么是 V8 JavaScript 脚本语言呢？该语言是一种被 V8 JavaScript 引擎所解析并执行的脚本语言。V8 JavaScript 引擎是由 Google 公司使用 C++语言开发的一种高性能 JavaScript 引擎，该引擎并不局限于在浏览 器中运行。Node.js 将其转用在了服务器中，并且为其提供了许多附加的具有各种不同用途的 API。例如， 在一个服务器中，经常需要处理各种二进制数据。在 JavaScript 脚本语言中，只具有非常有限的对二进制数 据的处理能力，而 Node.js 所提供的 Buffer 类则提供了丰富的对二进制数据的处理能力。 另外，在V8 JavaScript 引擎内部使用一种全新的编译技术。这意味着开发者编写的高端的 JavaScript 脚本代 码与开发者编写的低端的C语言具有非常相近的执行效率，这也是Node.js 服务器可以提供的一个重要特性。 开发周期短、开发成本低、学习成本低：Node.js 自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。 二、Node.js适合做什么？ 前后端编程语言环境统一。这类代表是雅虎。雅虎开放了 Cocktai 框架，利用自己深厚的前端沉淀，将 YUI3 这个前端框架的能力借助 Node 延伸到服务器端，使得使用者摆脱了日常工作中一边写 JavaScript—边写 PHP 所帯来的上下文交换负担。 Node带来的高性能 I/0 用于实时应用。Voxer 将 Node应用在实时语音上。国内腾讯的朋友网将 Node 应用在长连接中，以提供实时功能，花瓣网、蘑菇街等公司通过 socket.io 实现实时通知的功能。 并行 I/0 使得使用者可以更高效地利用分布式环境。阿里巴巴 eBay 是这方面的典型。 阿里巴巴的NodeFox和eBay的ql.io都是借用Node 并行 I/O 的能力，更高效地使用已有的数据。 并行 I/O •有效利用稳定接口提升Web渲染能力。雪球财经和 Linkedln 的移动版网站均是这种案例，撇弃同步等待式的顺序请求，大胆采用并行丨/〇，加速数据的获取进而提升 Web 的渲染速度。 云计算平台提供 Node 支持。微软将 Node 引入 Azure 的开发中，阿里云、百度均纷纷 在云服务器上提供 Node 应用托管服务，Joyent 更是云计算中提供 Node 支持的代表。这类平台看重 JavaScript 带来的开发上的优势，以及低资源占用、高性能的特点。 游戏开发领域。游戏领域对实时和并发有很高的要求，网易开源了 pomelo 实时框架， 可以应用在游戏和高实时应用中。 工具类应用。过去依赖 java 或其他语言构建的前端工具类应用，纷纷被一些前端工程 师用 Node 重写，用前端熟悉的语言为前端构建熟悉的工具。 三、Node.js环境搭建 Node.js 和 Java 非常像，跨平台的。不管是 Linux 还是 windows 编程是完全一致的（有一些不一样，比如路径的表述）。Linux 版本的 Node.js 环境和 windows 环境是不一样的，但是编程语言一样。 安装完成后，win+R:cmd—&gt;输入node --version (记得配置path) 四、Node.js开发工具配置 工欲善其事必先利其器，我选择的是VSCode，因为它强大的插件。微软有 Visual Studio这个宇宙最强IDE，Visual Studio Code 自然也不会弱(宇宙最强编辑器)，下面介绍一些VSCode中好用的插件： 1、代码片段(Snippet)插件 当你要从事更加前沿的开发的时候，你就需要一些额外的代码片段插件来辅助你编写ES6/ES7代码。 VS Code JavaScript(ES6) snippets：它是如今最流行的，安装了超过120万的插件。该插件为JavaScript、TypeScript、HTML、React和Vue提供了ES6语法支持。 JavaScript Snippet Pack：JavaScript代码片段集合。 Atom JavaScript Snippet：从Atom移植过来的JavaScript代码片段。 JavaScript Snippets：ES6代码片段，并且包含Mocha、Jasmine和其它BDD测试框架的代码片段。 2、语法插件 VS Code自带的针对JavaScript的语法高亮已经相当不错。你可以安装不同的主题来改变代码的颜色。不过，如果你想要更好的可读性，可以安装代码高亮插件。这里有一些推荐： JavaScript Atom Grammar：该插件将Visual Studio Code自带的JavaScript语法替换成了Atom编辑器的版本。 Babel JavaScript：支持 ES201x JavaScript、React、FlowType和GraphQL代码的语法高亮。 DotENV：如果你使用Node，你需要它。DotEnv提供.env文件的语法高亮。 3、码风格检查插件 为了保证整个团队代码格式的一致性，使用一个代码风格检查工具可以做到。ESLint是最流行的一个工具，因为它支持非常多的代码风格，包括标准的、Google和Airbnb。下面列出一些推荐的插件： ESLint：这个是最流行的代码风格检查插件，有超过670万的安装量。你可以在.eslintrc.json中配置。 JSHint：JSHint的代码风格检查插件。在项目的根目录下面，用.jshintrcfile配置。 JavaScript Standard Style: 一个无需配置的自带非常严格规则的代码风格检查插件。它强制要求你所有代码要遵循标准规则。 JSLint：JSLint的代码风格检查插件。 如果你想要了解各个插件的优缺点，可以看看这篇博客JavaScript代码风格检查插件大评比。 4、Node插件 每一个JavaScript项目至少需要安装一个Node包。这里推荐一些针对Node的插件： npm：使用package.json来验证已经安装的模块，确保已经安装的模块版本号正确，标记那些安装了但是没有在package.json列出来的包，以及那些还没有安装的包。 Node.js Modules IntelliSense：为JavaScript和TypeScript模块自动补全import语句。 Path IntelliSense：虽然并不是真的和Node相关，这个插件可以自动补全文件名，可以在输入时对本地文件进行智能提示。 Node exec：运行你执行当前的Node文件或者选中的部分代码。 View Node Package：通过此插件可以快速查看一个Node包的源代码。 Node Readme：快速打开npm包文档。 Search node_modules：搜索node_modules里面的代码，标准的搜索是不会包含该文件夹的。 Import Cost：显示引入的包的大小 5、代码格式化插件 你也许会发现，有时后复制粘贴完一段代码后，缩进的格式变乱，需要一行一行的调整十分麻烦。这个时候，你肯定想要一个代码格式化工具。 Beautify：安装量超过230万，Beautify是jsBeautifier的插件，支持JavaScript、JSON、CSS和HTML一键格式化。 Prettier Code Formatter：安装量超过150万，支持JavaScript、TypeScript和CSS的格式化，使用Prettier(一个深受大家喜爱的格式化插件)。 JS Refactor：提供了许多重构JavaScript 代码的方法，例如提取代码中的变量和方法，将函数转换为使用箭头函数或模板字面量和将函数导出。 JavaScript Booster：一个非常棒的重构工具，比如将var替换为const或则let，移除无用的else语句，将变量声明和变量初始化合并。应该说很大程度上受到Webstorm的启发。 6、浏览器插件 除非你直接在控制台写JavaScript代码，大多数时候是在浏览器中执行的。也就是说，每一次代码更新，你都需要刷新页面来重写载入代码。如果一直手动操作，是很繁琐的。我们可以用插件来替代。 Debugger for Chrome：你只需要在代码编辑器中设置断点，在浏览器中会在断点处暂停。 Live Server：在本地开发环境中，实时重新加载(reload)页面。 Preview on Web Server：提供web服务器和实时预览。 PHP Server：对于仅需要在客户端运行JavaScript 代码做测试非常有用。 Rest Client：你不需要使用浏览器或则一个CURL程序来测试REST API，通过Rest Client可以在编辑器内交互式运行HTTP请求。 7、框架插件 对于大多数项目，为了节省开发时间，你往往会使用一个合适的开发框架来快速开发。在VS Code上，大多数框架都有相应的插件支持。但是依然有很多框架并没有对应的插件。 Angular 6：超过220万的安装量，支持TypeScript、HTML、Angular Material ngRx、RxJS和Flex Layout。并且有172个Angular的代码片段。 Angular v5 snippets：超过270万的安装量，提供 TypeScript、RxJS、HTML和Docker文件的代码片段。 React Native/React/Redux snippets for es6/es7：为这些框架提供ES6/ES7语法的代码片段。 React Native Tools：提供智能提示、命令行工具和Debugging功能。 Vetur：为Vue框架提供语法高亮、代码片段、Emmet、格式化、代码风格检查、智能提示、调试帮助等。有非常详细的文档: vetur。 Ember：为Ember提供命令工具和智能提示。安装后，所有的ember cli命令都可以使用。 Cordova Tools：为Cordova插件和Ionic框架提供支持。提供代码智能提示、调试辅助以及其他特性。 jQuery Code Snippets：提供超过130个jQuery代码片段。 8、测试插件 在软件开发中，测试是必可不少的一个环节，特别是那些要上线到生产环境的项目。你可以看看我们这篇讲测试的文章: JavaScript Testing: Unit vs Functional vs Integration Tests。下面是一些流行的测试插件： Mocha sidebar：使用Mocha库来提供测试支持。使用该插件可以直接在代码中运行测试并将提示错误。 ES6 Mocha Snippets：提供ES6语法的 Mocha代码片段。充分利用箭头函数，尽量不使用大括号来保持代码的简洁，可配置允许使用分号。 Jasmine Code Snippets：Jasmine测试框架的代码片段。 Protractor Snippets：Protractor框架的端到端(end-to-end)测试片段，支持JavaScript和Typescript。 Node TDD：为Node和JavaScript项目提供test-driven development支持。在代码更新的时候可以自动触发代码的测试。 9、其它很酷的插件 我把它们分类到awesome类别，是因为它们真的很酷。 Quokka.js：一个很棒的调试工具，可以为您正在编写的代码提供实时反馈,能够预览变量的函数和计算值结果。请查看文档：文档 Paste as JSON：快速将JSON数据转换为JavaScript代码。 Code Metrics：这是一个用来计算JavaScript和TypeScript代码复杂度的插件。 10、插件包 VS Code的插件市场有一个类型叫插件包。它实际上已一个相互关联的插件的集合，方便一起安装，协同使用。 Nodejs Extension Pack：包含了ESLint、npm、JavaScript(ES6)代码片段、node_modules搜索、NPM智能提示和文件路径智能提示。 VS Code for Node.js – Development Pack ：NPM智能提示，ESLint，Chrome调试器，Code Metrics，Docker和导入包的开销计算。 Vue.js Extension Pack：包含大约12个VS Code插件，有些在本文没有提到，比如auto-rename-tag和auto-close-tag。 Ionic Extesion Pack：包含许多用于Ionic、Angular、RxJS、Cordova和HTML开发的插件。 11、VSCode 拓展插件推荐——提高 Node 和 Vue开发效率 Auto Close Tag 自动闭合HTML标签 Auto Rename Tag 修改HTML标签时，自动修改匹配的标签 Bookmarks 添加行书签 Can I Use HTML5、CSS3、SVG的浏览器兼容性检查 Code Runner 运行选中代码段（支持大量语言，包括Node） CodeBing 在VSCode中弹出浏览器并搜索，可编辑搜索引擎 Color Highlight 颜色值在代码中高亮显示 Color Picker 拾色器 Document This 注释文档生成 EditorConfig for VS Code EditorConfig插件 Emoji 在代码中输入emoji ESLint ESLint插件，高亮提示 File Peek 根据路径字符串，快速定位到文件 Font-awesome codes for html FontAwesome提示代码段 ftp-sync 同步文件到ftp Git Blame 在状态栏显示当前行的Git信息 Git History(git log) 查看git log GitLens 显示文件最近的commit和作者，显示当前行commit信息 Guides 高亮缩进基准线 Gulp Snippets Gulp代码段 HTML CSS Class Completion CSS class提示 HTML CSS Support css提示（支持vue） HTMLHint HTML格式提示 Indenticator 缩进高亮 JavaScript (ES6) code snippets ES6语法代码段 language-stylus Stylus语法高亮和提示 Lodash Lodash代码段 markdownlint Markdown格式提示 MochaSnippets Mocha代码段 Node modules resolve 快速导航到Node模块 npm 运行npm命令 npm Intellisense 导入模块时，提示已安装模块名称 Output Colorizer 彩色输出信息 Partial Diff 对比两段代码或文件 Path Autocomplete 路径完成提示 Path Intellisense 另一个路径完成提示 Prettify JSON 格式化JSON Project Manager 快速切换项目 REST Client 发送REST风格的HTTP请求 Settings Sync VSCode设置同步到Gist String Manipulation 字符串转换处理（驼峰、大写开头、下划线等等） Test Spec Generator 测试用例生成（支持chai、should、jasmine） TODO Parser Todo管理 Version Lens package.json文件显示模块当前版本和最新版本 vetur 目前比较好的Vue语法高亮 View Node Package 快速打开选中模块的主页和代码仓库 vscode-icons 文件图标，方便定位文件 VSCode Great Icons 文件图标拓展 VueHelper Vue2代码段（包括Vue2 api、vue-router2、vuex2） 附录：VSCode首选项配置 123456789101112131415161718192021222324252627282930313233&#123; &quot;editor.tabSize&quot;: 2, &quot;files.associations&quot;: &#123; &quot;*.vue&quot;: &quot;vue&quot; &#125;, &quot;eslint.autoFixOnSave&quot;: true, &quot;eslint.options&quot;: &#123; &quot;extensions&quot;: [ &quot;.js&quot;, &quot;.vue&quot; ] &#125;, &quot;eslint.validate&quot;: [ &quot;javascript&quot;, &quot;javascriptreact&quot;, &quot;vue&quot;, &quot;vue-html&quot; ], &quot;search.exclude&quot;: &#123; &quot;**/node_modules&quot;: true, &quot;**/bower_components&quot;: true, &quot;**/dist&quot;: true &#125;, &quot;emmet.syntaxProfiles&quot;: &#123; &quot;javascript&quot;: &quot;jsx&quot;, &quot;vue&quot;: &quot;html&quot;, &quot;vue-html&quot;: &quot;html&quot; &#125;, &quot;extensions.autoUpdate&quot;: true, &quot;editor.renderWhitespace&quot;: &quot;boundary&quot;, &quot;editor.cursorBlinking&quot;: &quot;smooth&quot;, &quot;workbench.welcome.enabled&quot;: true&#125; VS Code能够如此流行的一个原因就是拥有大量的高质量插件。它前所未有的提高了编码的效率。比如ESLint助你减少代码失误，Debugger for Chrome让你更加方便去Debugging。Node.js的智能引入提示让你可以让你正确引入所需模块，Live Server和 REST Client可以让你省去频繁切换到外部工具的麻烦。希望介绍的这些插件可以帮助你提高工作效率。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
